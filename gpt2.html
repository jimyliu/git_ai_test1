<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AI Image Frame Tool ‚Äî 2025-12-30 22:23:22</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#eaf0ff;
      --muted:#a9b5d6;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --shadow2: 0 8px 22px rgba(0,0,0,.22);
      --radius: 14px;
      --radius2: 18px;
      --gap: 12px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "PingFang TC","PingFangTC-Regular","Heiti TC", Arial, Helvetica, sans-serif;
      background: radial-gradient(1200px 700px at 25% 10%, #16224a 0%, rgba(22,34,74,0) 60%),
                  radial-gradient(900px 600px at 70% 30%, #1b2f66 0%, rgba(27,47,102,0) 65%),
                  var(--bg);
      color:var(--text);
    }

    header{
      padding: 16px 18px 10px;
      position: sticky;
      top: 0;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,16,32,.85), rgba(11,16,32,.35));
      border-bottom:1px solid var(--border);
      z-index: 5;
    }
    .titlebar{
      display:flex; align-items:flex-end; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: 18px;
      font-weight: 750;
      letter-spacing: .2px;
    }
    .subtitlebar{
      margin-top:6px;
      color:var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .kbd{
      display:inline-block;
      padding: 2px 7px;
      border:1px solid var(--border);
      border-bottom-color: rgba(255,255,255,.18);
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      box-shadow: 0 1px 0 rgba(255,255,255,.06) inset;
      font-size: 11px;
      color: #dfe7ff;
      white-space: nowrap;
    }

    main{
      padding: 14px 14px 20px;
      max-width: 1600px;
      margin: 0 auto;
    }

    .layout{
      display:grid;
      grid-template-columns: 360px minmax(360px, 1fr) 360px;
      gap: var(--gap);
      align-items: start;
    }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow2);
      overflow:hidden;
    }
    .panel .panel-h{
      padding: 12px 12px 10px;
      border-bottom:1px solid var(--border);
      background: rgba(255,255,255,.03);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panel .panel-h b{
      font-size: 13px;
      letter-spacing:.2px;
    }
    .panel .panel-b{
      padding: 12px;
    }

    .group{
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: rgba(0,0,0,.16);
      box-shadow: 0 1px 0 rgba(255,255,255,.04) inset;
      margin-bottom: 10px;
    }
    .group:last-child{ margin-bottom: 0; }
    .group h3{
      margin: 0 0 10px;
      font-size: 12px;
      color: #dfe7ff;
      letter-spacing: .25px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .hint{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.35;
      margin: 6px 0 0;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-bottom: 10px;
    }
    .row:last-child{ margin-bottom: 0; }

    label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      font-size: 12px;
      color: #dce5ff;
    }
    .small{
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }

    input[type="file"]{ width:100%; }
    input[type="text"], input[type="number"], select, textarea{
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(12,18,38,.65);
      color: var(--text);
      padding: 10px 10px;
      outline: none;
      box-shadow: 0 1px 0 rgba(255,255,255,.04) inset;
    }
    textarea{ resize: vertical; min-height: 64px; max-height: 160px; }

    input[type="range"]{ width:100%; }
    input[type="color"]{
      width: 44px; height: 32px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      padding: 0;
    }

    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .three{
      display:grid;
      grid-template-columns: 1.1fr .9fr .9fr;
      gap: 10px;
      align-items:end;
    }
    .inline{
      display:flex; gap: 10px; align-items:center;
    }

    .btnrow{
      display:flex; gap:10px; flex-wrap:wrap;
    }
    button{
      appearance:none;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      color: var(--text);
      padding: 10px 12px;
      font-weight: 650;
      cursor:pointer;
      box-shadow: var(--shadow);
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
    }
    button:hover{ background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06)); }
    button:active{ transform: translateY(1px); }
    button.secondary{
      background: rgba(255,255,255,.05);
      box-shadow: none;
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,80,80,.22), rgba(255,80,80,.10));
      border-color: rgba(255,120,120,.35);
    }

    .stage{
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .canvasWrap{
      position: relative;
      border-radius: var(--radius2);
      border:1px solid var(--border);
      background: rgba(0,0,0,.20);
      box-shadow: var(--shadow2);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 420px;
    }
    canvas{
      max-width: 100%;
      max-height: 72vh;
      width: auto;
      height: auto;
      display:block;
      touch-action: none; /* critical for pointer/touch dragging */
      background: transparent;
    }
    .stageHelp{
      display:flex; gap:10px; flex-wrap:wrap;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.05);
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: rgba(255,255,255,.55);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      flex:0 0 auto;
    }

    .footerNote{
      color: var(--muted);
      font-size: 11px;
      margin-top: 8px;
      line-height: 1.35;
    }

    @media (max-width: 1100px){
      .layout{ grid-template-columns: 1fr; }
      .canvasWrap{ min-height: 360px; }
    }
  </style>
</head>
<body>
<header>
  <div class="titlebar">
    <h1>AI Image Frame Tool ‚Äî 2025-12-30 22:23:22</h1>
    <div class="btnrow">
      <button id="btnRandom">üé≤ Random Style</button>
      <button id="btnCenter" class="secondary">üéØ Auto-Center</button>
      <button id="btnExport">‚¨áÔ∏è Export PNG</button>
    </div>
  </div>
  <div class="subtitlebar">
    Drag directly on the canvas:
    <span class="kbd">Main Image + Frame</span>
    <span class="kbd">Title</span>
    <span class="kbd">Subtitle</span>
    ‚Ä¢ Works in <b>Safari</b> + <b>Chrome</b> ‚Ä¢ Browser-only ‚Ä¢ Canvas-only rendering
  </div>
</header>

<main>
  <div class="layout">
    <!-- LEFT CONTROLS -->
    <section class="panel">
      <div class="panel-h">
        <b>Left Controls</b>
        <span class="small">Background + Canvas</span>
      </div>
      <div class="panel-b">
        <div class="group">
          <h3>üåÑ Background Image Layer</h3>

          <div class="row">
            <label>
              <span>Load Background Image</span>
              <span class="small">(fills canvas)</span>
            </label>
            <input id="bgFile" type="file" accept="image/*" />
          </div>

          <div class="row">
            <label>
              <span>Background Fit</span>
              <span class="small">cover / contain</span>
            </label>
            <select id="bgFit">
              <option value="cover">Cover (fill canvas)</option>
              <option value="contain">Contain (show whole image)</option>
            </select>
          </div>

          <div class="row">
            <label>
              <span>Background Transparency</span>
              <span class="small"><span id="bgTVal">20</span>% (higher = more transparent)</span>
            </label>
            <input id="bgTransparency" type="range" min="20" max="100" value="20" />
          </div>

          <div class="row">
            <div class="btnrow">
              <button id="btnClearBg" class="secondary">Clear Background</button>
            </div>
          </div>

          <p class="hint">
            Background is <b>not draggable</b>. It always stays at the bottom layer.
          </p>
        </div>

        <div class="group">
          <h3>üß± Canvas Settings</h3>

          <div class="row">
            <label>
              <span>Canvas Size Mode</span>
              <span class="small">auto / bg / main / custom</span>
            </label>
            <select id="canvasMode">
              <option value="auto">Auto (background &gt; main)</option>
              <option value="background">Use Background Size</option>
              <option value="main">Use Main Size</option>
              <option value="custom">Custom</option>
            </select>
          </div>

          <div class="two">
            <div class="row">
              <label><span>Width</span><span class="small">px</span></label>
              <input id="canvasW" type="number" min="64" step="1" />
            </div>
            <div class="row">
              <label><span>Height</span><span class="small">px</span></label>
              <input id="canvasH" type="number" min="64" step="1" />
            </div>
          </div>

          <div class="row">
            <div class="btnrow">
              <button id="btnApplyCanvas" class="secondary">Apply Canvas Size</button>
              <button id="btnResetAll" class="danger">Reset All</button>
            </div>
          </div>

          <p class="hint">
            Exported PNG is <b>pixel-perfect</b> to the canvas dimensions above.
          </p>
        </div>
      </div>
    </section>

    <!-- CANVAS PREVIEW -->
    <section class="panel">
      <div class="panel-h">
        <b>Canvas Preview</b>
        <span class="small">Layer Order: BG ‚Üí Main ‚Üí Frame ‚Üí Title ‚Üí Subtitle</span>
      </div>
      <div class="stage">
        <div class="canvasWrap">
          <canvas id="c"></canvas>
        </div>

        <div class="stageHelp">
          <span class="chip"><span class="dot"></span>Tip: drag objects directly on the canvas (mouse or touch).</span>
          <span class="chip"><span class="dot"></span>Tip: use ‚ÄúRandom Style‚Äù for quick inspiration.</span>
          <span class="chip"><span class="dot"></span>Tip: ‚ÄúAuto-Center‚Äù snaps main + texts to smart defaults.</span>
        </div>

        <div class="footerNote">
          Safari note: If ‚ÄúExport PNG‚Äù doesn‚Äôt download automatically on iOS, it will open the PNG in a new tab (long-press ‚Üí Save).
        </div>
      </div>
    </section>

    <!-- RIGHT CONTROLS -->
    <section class="panel">
      <div class="panel-h">
        <b>Right Controls</b>
        <span class="small">Main + Frame + Text</span>
      </div>
      <div class="panel-b">

        <div class="group">
          <h3>üñº Main Image Layer</h3>

          <div class="row">
            <label>
              <span>Load Main Image (Foreground)</span>
              <span class="small">(draggable)</span>
            </label>
            <input id="mainFile" type="file" accept="image/*" />
          </div>

          <div class="row">
            <label>
              <span>Main Transparency</span>
              <span class="small"><span id="mainTVal">20</span>% (higher = more transparent)</span>
            </label>
            <input id="mainTransparency" type="range" min="20" max="100" value="20" />
          </div>

          <div class="row">
            <label>
              <span>Main Scale</span>
              <span class="small"><span id="mainScaleVal">100</span>%</span>
            </label>
            <input id="mainScale" type="range" min="10" max="250" value="100" />
          </div>

          <div class="row">
            <div class="btnrow">
              <button id="btnClearMain" class="secondary">Clear Main</button>
              <button id="btnFitMain" class="secondary">Fit Main to Canvas</button>
            </div>
          </div>

          <p class="hint">
            <b>Main image and its frame move together</b> (single drag unit).
          </p>
        </div>

        <div class="group">
          <h3>üñº Frame / Border</h3>

          <div class="two">
            <div class="row">
              <label><span>Frame Color</span><span class="small">wraps main only</span></label>
              <input id="frameColor" type="color" value="#ffffff" />
            </div>
            <div class="row">
              <label><span>Thickness</span><span class="small"><span id="frameThVal">18</span> px</span></label>
              <input id="frameThickness" type="range" min="0" max="120" value="18" />
            </div>
          </div>

          <div class="row">
            <label>
              <span>Frame Corner Radius</span>
              <span class="small"><span id="frameRadVal">18</span> px</span>
            </label>
            <input id="frameRadius" type="range" min="0" max="140" value="18" />
          </div>

          <p class="hint">
            Thickness is <b>uniform</b> on all sides.
          </p>
        </div>

        <div class="group">
          <h3>üß† Preset Captions</h3>
          <div class="row">
            <label><span>Pick a preset</span><span class="small">fills Title + Subtitle</span></label>
            <select id="preset">
              <option value="">‚Äî Choose ‚Äî</option>
              <option value="1">Joy to the world ‚Ä¢ Peace begins here</option>
              <option value="2">Grace upon grace ‚Ä¢ Today is a gift</option>
              <option value="3">‰∏ÄËµ∑Âä†Ê≤πÂä†Ê≤π!!! ‚Ä¢ Pray for everything</option>
              <option value="4">Yes, Virginia ‚Ä¢ There is a Santa Claus</option>
              <option value="5">Thankful ‚Ä¢ Every moment matters</option>
            </select>
          </div>
          <p class="hint">
            You can still edit, style, and drag text after applying a preset.
          </p>
        </div>

        <div class="group">
          <h3>‚úçÔ∏è Title Text Layer</h3>

          <div class="row">
            <label><span>Title Text</span><span class="small">real-time</span></label>
            <textarea id="titleText" placeholder="Enter title...">Merry Christmas</textarea>
          </div>

          <div class="row">
            <label><span>Font Family (Title)</span><span class="small">Safari-safe</span></label>
            <select id="titleFont"></select>
          </div>

          <div class="three">
            <div class="row">
              <label><span>Text Color</span><span class="small">picker</span></label>
              <input id="titleColor" type="color" value="#ffffff" />
            </div>
            <div class="row">
              <label><span>Size</span><span class="small">pt</span></label>
              <input id="titleSize" type="range" min="14" max="800" value="14" />
            </div>
            <div class="row">
              <label><span>Size</span><span class="small">pt</span></label>
              <input id="titleSizeNum" type="number" min="14" max="800" value="14" />
            </div>
          </div>

          <div class="two">
            <div class="row">
              <label><span>BG Color</span><span class="small">behind text</span></label>
              <input id="titleBgColor" type="color" value="#000000" />
            </div>
            <div class="row">
              <label><span>BG Transparency</span><span class="small"><span id="titleBgTVal">55</span>%</span></label>
              <input id="titleBgTransparency" type="range" min="0" max="100" value="55" />
            </div>
          </div>

          <div class="row">
            <label class="inline">
              <input id="titleAutoFit" type="checkbox" checked />
              <span>Smart Auto-Fit (keeps title within canvas width)</span>
            </label>
          </div>

          <p class="hint">
            Drag the <b>Title</b> directly on the canvas (mouse or touch).
          </p>
        </div>

        <div class="group">
          <h3>‚úçÔ∏è Subtitle Text Layer</h3>

          <div class="row">
            <label><span>Subtitle Text</span><span class="small">real-time</span></label>
            <textarea id="subtitleText" placeholder="Enter subtitle...">Peace ‚Ä¢ Joy ‚Ä¢ Hope</textarea>
          </div>

          <div class="row">
            <label><span>Font Family (Subtitle)</span><span class="small">Safari-safe</span></label>
            <select id="subtitleFont"></select>
          </div>

          <div class="three">
            <div class="row">
              <label><span>Text Color</span><span class="small">picker</span></label>
              <input id="subtitleColor" type="color" value="#ffffff" />
            </div>
            <div class="row">
              <label><span>Size</span><span class="small">pt</span></label>
              <input id="subtitleSize" type="range" min="14" max="800" value="42" />
            </div>
            <div class="row">
              <label><span>Size</span><span class="small">pt</span></label>
              <input id="subtitleSizeNum" type="number" min="14" max="800" value="42" />
            </div>
          </div>

          <div class="two">
            <div class="row">
              <label><span>BG Color</span><span class="small">behind text</span></label>
              <input id="subtitleBgColor" type="color" value="#000000" />
            </div>
            <div class="row">
              <label><span>BG Transparency</span><span class="small"><span id="subtitleBgTVal">65</span>%</span></label>
              <input id="subtitleBgTransparency" type="range" min="0" max="100" value="65" />
            </div>
          </div>

          <div class="row">
            <label class="inline">
              <input id="subtitleAutoFit" type="checkbox" checked />
              <span>Smart Auto-Fit (keeps subtitle within canvas width)</span>
            </label>
          </div>

          <p class="hint">
            Drag the <b>Subtitle</b> directly on the canvas (mouse or touch).
          </p>
        </div>

      </div>
    </section>
  </div>
</main>

<script>
(() => {
  "use strict";

  // ---------- DOM ----------
  const el = (id) => document.getElementById(id);

  const canvas = el("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  // Left
  const bgFile = el("bgFile");
  const bgFit = el("bgFit");
  const bgTransparency = el("bgTransparency");
  const bgTVal = el("bgTVal");
  const btnClearBg = el("btnClearBg");

  const canvasMode = el("canvasMode");
  const canvasW = el("canvasW");
  const canvasH = el("canvasH");
  const btnApplyCanvas = el("btnApplyCanvas");
  const btnResetAll = el("btnResetAll");

  // Right
  const mainFile = el("mainFile");
  const mainTransparency = el("mainTransparency");
  const mainTVal = el("mainTVal");
  const mainScale = el("mainScale");
  const mainScaleVal = el("mainScaleVal");
  const btnClearMain = el("btnClearMain");
  const btnFitMain = el("btnFitMain");

  const frameColor = el("frameColor");
  const frameThickness = el("frameThickness");
  const frameThVal = el("frameThVal");
  const frameRadius = el("frameRadius");
  const frameRadVal = el("frameRadVal");

  const preset = el("preset");

  const titleText = el("titleText");
  const titleFont = el("titleFont");
  const titleColor = el("titleColor");
  const titleSize = el("titleSize");
  const titleSizeNum = el("titleSizeNum");
  const titleBgColor = el("titleBgColor");
  const titleBgTransparency = el("titleBgTransparency");
  const titleBgTVal = el("titleBgTVal");
  const titleAutoFit = el("titleAutoFit");

  const subtitleText = el("subtitleText");
  const subtitleFont = el("subtitleFont");
  const subtitleColor = el("subtitleColor");
  const subtitleSize = el("subtitleSize");
  const subtitleSizeNum = el("subtitleSizeNum");
  const subtitleBgColor = el("subtitleBgColor");
  const subtitleBgTransparency = el("subtitleBgTransparency");
  const subtitleBgTVal = el("subtitleBgTVal");
  const subtitleAutoFit = el("subtitleAutoFit");

  // Top buttons
  const btnRandom = el("btnRandom");
  const btnCenter = el("btnCenter");
  const btnExport = el("btnExport");

  // ---------- FONT LIST (ORDER MUST MATCH EXACTLY) ----------
  const FONT_ITEMS = [
    // Traditional Chinese (exact order)
    { label: "PingFang TCÔºàËòãÊñπ-ÁπÅÔºâ‚Äî ‚≠ê Primary", value: "\"PingFang TC\",\"PingFangTC-Regular\",\"Heiti TC\",system-ui,sans-serif" },
    { label: "PingFang TC", value: "\"PingFang TC\",\"PingFangTC-Regular\",\"Heiti TC\",system-ui,sans-serif" },
    { label: "PingFangTC-Regular", value: "\"PingFangTC-Regular\",\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
    { label: "PingFangTC-Medium", value: "\"PingFangTC-Medium\",\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
    { label: "PingFangTC-Semibold", value: "\"PingFangTC-Semibold\",\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
    { label: "Heiti TCÔºàÈªëÈ´î-ÁπÅÔºâ", value: "\"Heiti TC\",\"PingFang TC\",system-ui,sans-serif" },
    { label: "Heiti TC", value: "\"Heiti TC\",\"PingFang TC\",system-ui,sans-serif" },
    { label: "Heiti TC Light", value: "\"Heiti TC Light\",\"Heiti TC\",\"PingFang TC\",system-ui,sans-serif" },
    { label: "Heiti TC Medium", value: "\"Heiti TC Medium\",\"Heiti TC\",\"PingFang TC\",system-ui,sans-serif" },
    { label: "Songti TCÔºàÂÆãÈ´î-ÁπÅÔºâ", value: "\"Songti TC\",\"Songti TC Regular\",\"PingFang TC\",system-ui,serif" },
    { label: "Songti TC", value: "\"Songti TC\",\"Songti TC Regular\",\"PingFang TC\",system-ui,serif" },
    { label: "Songti TC Regular", value: "\"Songti TC Regular\",\"Songti TC\",\"PingFang TC\",system-ui,serif" },
    { label: "Songti TC Bold", value: "\"Songti TC Bold\",\"Songti TC\",\"PingFang TC\",system-ui,serif" },
    { label: "Kaiti TCÔºàÊ•∑È´î-ÁπÅÔºâ", value: "\"Kaiti TC\",\"PingFang TC\",\"Songti TC\",system-ui,serif" },
    { label: "Kaiti TC", value: "\"Kaiti TC\",\"PingFang TC\",\"Songti TC\",system-ui,serif" },
    // Latin / System
    { label: "system-ui", value: "system-ui,-apple-system,\"PingFang TC\",\"Heiti TC\",sans-serif" },
    { label: "Arial", value: "Arial,\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
    { label: "Helvetica", value: "Helvetica,Arial,\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
  ];

  function populateFonts(selectEl){
    selectEl.innerHTML = "";
    for (const item of FONT_ITEMS){
      const opt = document.createElement("option");
      opt.textContent = item.label;
      opt.value = item.value;
      selectEl.appendChild(opt);
    }
  }
  populateFonts(titleFont);
  populateFonts(subtitleFont);

  // ---------- STATE ----------
  const state = {
    canvas: { w: 1000, h: 600, mode: "auto" },

    bg: {
      img: null,
      fit: "cover",
      transparencyPct: 20, // higher = more transparent
    },

    main: {
      img: null,
      centerX: 500,
      centerY: 300,
      scalePct: 100,
      transparencyPct: 20, // higher = more transparent
      naturalW: 0,
      naturalH: 0,
    },

    frame: {
      color: "#ffffff",
      thickness: 18,
      radius: 18,
    },

    title: {
      text: "Merry Christmas",
      fontFamily: FONT_ITEMS[0].value,
      sizePt: 86,
      color: "#ffffff",
      bgColor: "#000000",
      bgTransparencyPct: 55, // 0..100 higher more transparent
      centerX: 500,
      centerY: 120,
      autoFit: true,
    },

    subtitle: {
      text: "Peace ‚Ä¢ Joy ‚Ä¢ Hope",
      fontFamily: FONT_ITEMS[0].value,
      sizePt: 42,
      color: "#ffffff",
      bgColor: "#000000",
      bgTransparencyPct: 65,
      centerX: 500,
      centerY: 510,
      autoFit: true,
    },
  };

  // ---------- HELPERS ----------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function hexToRgb(hex){
    const h = (hex || "").replace("#","").trim();
    if (h.length === 3){
      const r = parseInt(h[0]+h[0], 16);
      const g = parseInt(h[1]+h[1], 16);
      const b = parseInt(h[2]+h[2], 16);
      return { r,g,b };
    }
    if (h.length === 6){
      const r = parseInt(h.slice(0,2), 16);
      const g = parseInt(h.slice(2,4), 16);
      const b = parseInt(h.slice(4,6), 16);
      return { r,g,b };
    }
    return { r:0, g:0, b:0 };
  }

  // Slider value is "transparency %", higher = more transparent => alpha decreases
  function transparencyToAlpha(transparencyPct){
    const t = clamp(Number(transparencyPct) || 0, 0, 100);
    return 1 - (t / 100);
  }

  function setCanvasSize(w,h){
    const W = Math.max(64, Math.floor(w));
    const H = Math.max(64, Math.floor(h));
    state.canvas.w = W;
    state.canvas.h = H;
    canvas.width = W;
    canvas.height = H;

    // Keep UI inputs in sync
    canvasW.value = W;
    canvasH.value = H;

    // Recenter defaults sensibly
    state.main.centerX = clamp(state.main.centerX, 0, W);
    state.main.centerY = clamp(state.main.centerY, 0, H);
    state.title.centerX = clamp(state.title.centerX, 0, W);
    state.title.centerY = clamp(state.title.centerY, 0, H);
    state.subtitle.centerX = clamp(state.subtitle.centerX, 0, W);
    state.subtitle.centerY = clamp(state.subtitle.centerY, 0, H);

    smartAutoFitAll();
    render();
  }

  function syncCanvasSizeFromMode(){
    const mode = state.canvas.mode;

    if (mode === "custom"){
      const w = Number(canvasW.value) || state.canvas.w;
      const h = Number(canvasH.value) || state.canvas.h;
      setCanvasSize(w, h);
      return;
    }

    const bg = state.bg.img;
    const main = state.main.img;

    if (mode === "background"){
      if (bg) setCanvasSize(bg.naturalWidth || bg.width, bg.naturalHeight || bg.height);
      return;
    }
    if (mode === "main"){
      if (main) setCanvasSize(main.naturalWidth || main.width, main.naturalHeight || main.height);
      return;
    }

    // auto: background > main > keep current
    if (bg) setCanvasSize(bg.naturalWidth || bg.width, bg.naturalHeight || bg.height);
    else if (main) setCanvasSize(main.naturalWidth || main.width, main.naturalHeight || main.height);
    else setCanvasSize(state.canvas.w, state.canvas.h);
  }

  function readFileAsDataURL(file){
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onerror = () => reject(new Error("Failed to read file."));
      fr.onload = () => resolve(String(fr.result || ""));
      fr.readAsDataURL(file);
    });
  }

  async function loadImageFromFile(file){
    const url = await readFileAsDataURL(file);
    return await new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error("Failed to load image."));
      img.src = url;
    });
  }

  function drawRoundedRectPath(ctx, x, y, w, h, r){
    const rr = clamp(r, 0, Math.min(w, h) / 2);
    ctx.beginPath();
    if (rr <= 0){
      ctx.rect(x, y, w, h);
      return;
    }
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  // ---------- LAYOUT / FIT ----------
  function computeBgDrawRect(){
    const W = state.canvas.w, H = state.canvas.h;
    const img = state.bg.img;
    if (!img) return null;

    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    if (!iw || !ih) return null;

    const canvasAR = W / H;
    const imgAR = iw / ih;

    let dw, dh;
    if (state.bg.fit === "cover"){
      if (imgAR > canvasAR){
        dh = H;
        dw = Math.ceil(H * imgAR);
      } else {
        dw = W;
        dh = Math.ceil(W / imgAR);
      }
    } else { // contain
      if (imgAR > canvasAR){
        dw = W;
        dh = Math.ceil(W / imgAR);
      } else {
        dh = H;
        dw = Math.ceil(H * imgAR);
      }
    }
    const dx = Math.floor((W - dw) / 2);
    const dy = Math.floor((H - dh) / 2);
    return { dx, dy, dw, dh };
  }

  function computeMainDrawRect(){
    const img = state.main.img;
    if (!img) return null;

    const iw = state.main.naturalW || (img.naturalWidth || img.width);
    const ih = state.main.naturalH || (img.naturalHeight || img.height);
    if (!iw || !ih) return null;

    const s = clamp(state.main.scalePct, 10, 250) / 100;
    const dw = iw * s;
    const dh = ih * s;
    const dx = state.main.centerX - dw/2;
    const dy = state.main.centerY - dh/2;
    return { dx, dy, dw, dh };
  }

  function fitMainToCanvas(){
    const img = state.main.img;
    if (!img) return;

    const W = state.canvas.w, H = state.canvas.h;
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    if (!iw || !ih) return;

    // Fit inside with margin
    const margin = Math.min(W,H) * 0.06;
    const maxW = Math.max(1, W - margin*2);
    const maxH = Math.max(1, H - margin*2);
    const s = Math.min(maxW/iw, maxH/ih);

    state.main.scalePct = clamp(Math.floor(s*100), 10, 250);
    mainScale.value = state.main.scalePct;
    mainScaleVal.textContent = String(state.main.scalePct);

    state.main.centerX = W/2;
    state.main.centerY = H/2;

    render();
  }

  function autoCenterAll(){
    const W = state.canvas.w, H = state.canvas.h;

    state.main.centerX = W/2;
    state.main.centerY = H/2;

    state.title.centerX = W/2;
    state.title.centerY = Math.max(10, H*0.16);

    state.subtitle.centerX = W/2;
    state.subtitle.centerY = Math.max(10, H*0.86);

    // Smart sizes
    smartAutoFitAll();
    render();
  }

  // ---------- TEXT MEASURE / HIT TEST ----------
  function setTextStyleFor(ctx, layer){
    // Use pt as px for consistent browser-only behavior
    ctx.font = `${layer.sizePt}px ${layer.fontFamily}`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
  }

  function getTextBox(layer){
    const text = (layer.text || "").toString();
    if (!text) return { x: layer.centerX, y: layer.centerY, w: 0, h: 0, padX: 0, padY: 0 };

    ctx.save();
    setTextStyleFor(ctx, layer);
    const metrics = ctx.measureText(text);
    ctx.restore();

    const w = Math.ceil(metrics.width);
    const h = Math.ceil(layer.sizePt * 1.15);
    const padX = Math.ceil(Math.max(8, layer.sizePt * 0.18));
    const padY = Math.ceil(Math.max(6, layer.sizePt * 0.14));

    return {
      x: layer.centerX - (w/2) - padX,
      y: layer.centerY - (h/2) - padY,
      w: w + padX*2,
      h: h + padY*2,
      padX, padY
    };
  }

  function pointInRect(px, py, r){
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  function hitTest(px, py){
    // Interaction priority (topmost first): Subtitle, Title, Main (frame+image)
    const subBox = getTextBox(state.subtitle);
    if (state.subtitle.text && pointInRect(px, py, subBox)) return "subtitle";

    const titleBox = getTextBox(state.title);
    if (state.title.text && pointInRect(px, py, titleBox)) return "title";

    const mainRect = computeMainDrawRect();
    if (mainRect && pointInRect(px, py, { x: mainRect.dx, y: mainRect.dy, w: mainRect.dw, h: mainRect.dh })) return "main";

    return null;
  }

  // ---------- SMART AUTOFIT ----------
  function smartFitTextToWidth(layer, maxWidthPx){
    const text = (layer.text || "").toString().trim();
    if (!text) return;

    // Leave padding room
    const target = Math.max(60, maxWidthPx * 0.92);

    let size = clamp(layer.sizePt, 14, 800);
    let loops = 0;

    ctx.save();
    while (loops++ < 40){
      ctx.font = `${size}px ${layer.fontFamily}`;
      const w = ctx.measureText(text).width;
      if (w > target && size > 14){
        size = Math.max(14, Math.floor(size * 0.90));
        continue;
      }
      if (w < target * 0.70 && size < 800){
        // gently increase if too small
        const newSize = Math.min(800, Math.ceil(size * 1.06));
        if (newSize === size) break;
        size = newSize;
        continue;
      }
      break;
    }
    ctx.restore();

    layer.sizePt = clamp(size, 14, 800);
  }

  function smartAutoFitAll(){
    const W = state.canvas.w;
    if (state.title.autoFit) smartFitTextToWidth(state.title, W);
    if (state.subtitle.autoFit) smartFitTextToWidth(state.subtitle, W);

    // Sync UI
    titleSize.value = String(state.title.sizePt);
    titleSizeNum.value = String(state.title.sizePt);
    subtitleSize.value = String(state.subtitle.sizePt);
    subtitleSizeNum.value = String(state.subtitle.sizePt);
  }

  // ---------- RENDER (STRICT LAYER ORDER) ----------
  function clear(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  function render(){
    const W = state.canvas.w, H = state.canvas.h;

    clear();

    // 1) Background Image Layer
    if (state.bg.img){
      const r = computeBgDrawRect();
      if (r){
        ctx.save();
        ctx.globalAlpha = transparencyToAlpha(state.bg.transparencyPct);
        ctx.drawImage(state.bg.img, r.dx, r.dy, r.dw, r.dh);
        ctx.restore();
      }
    }

    // 2) Main Image Layer
    const mainRect = computeMainDrawRect();
    if (state.main.img && mainRect){
      ctx.save();
      ctx.globalAlpha = transparencyToAlpha(state.main.transparencyPct);
      ctx.drawImage(state.main.img, mainRect.dx, mainRect.dy, mainRect.dw, mainRect.dh);
      ctx.restore();
    }

    // 3) Frame / Border Layer (wraps main image only)
    if (mainRect && state.frame.thickness > 0){
      ctx.save();
      ctx.lineWidth = state.frame.thickness;
      ctx.strokeStyle = state.frame.color;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      // Draw stroke fully visible inside/outside with half-thickness padding
      const half = state.frame.thickness / 2;
      const x = mainRect.dx - half;
      const y = mainRect.dy - half;
      const w = mainRect.dw + state.frame.thickness;
      const h = mainRect.dh + state.frame.thickness;

      drawRoundedRectPath(ctx, x, y, w, h, state.frame.radius);
      ctx.stroke();
      ctx.restore();
    }

    // 4) Title Text Layer
    drawTextLayer(state.title);

    // 5) Subtitle Text Layer
    drawTextLayer(state.subtitle);
  }

  function drawTextLayer(layer){
    const text = (layer.text || "").toString();
    if (!text) return;

    // Background rect
    const box = getTextBox(layer);
    if (box.w > 0 && box.h > 0){
      const rgb = hexToRgb(layer.bgColor);
      const alpha = transparencyToAlpha(layer.bgTransparencyPct); // higher transparency => lower alpha
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
      // subtle rounding
      drawRoundedRectPath(ctx, box.x, box.y, box.w, box.h, Math.min(16, Math.max(8, layer.sizePt * 0.18)));
      ctx.fill();
      ctx.restore();
    }

    // Text
    ctx.save();
    setTextStyleFor(ctx, layer);
    ctx.fillStyle = layer.color;
    ctx.globalAlpha = 1; // text not affected by image opacity sliders
    ctx.fillText(text, layer.centerX, layer.centerY);
    ctx.restore();
  }

  // ---------- EXPORT ----------
  async function exportPNG(){
    try{
      // render ensures up-to-date
      render();

      const dataUrl = canvas.toDataURL("image/png");
      // Prefer blob for large canvases
      if (canvas.toBlob){
        canvas.toBlob((blob) => {
          if (!blob){
            fallbackOpen(dataUrl);
            return;
          }
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "framed.png";
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        }, "image/png");
      } else {
        fallbackOpen(dataUrl);
      }
    } catch (e){
      // As last resort, open in new tab
      fallbackOpen(canvas.toDataURL("image/png"));
    }
  }

  function fallbackOpen(dataUrl){
    const w = window.open();
    if (w){
      w.document.write(`<title>PNG Export</title><img src="${dataUrl}" style="max-width:100%;height:auto;display:block;margin:0 auto;">`);
      w.document.close();
    } else {
      // If pop-up blocked, try direct navigation
      window.location.href = dataUrl;
    }
  }

  // ---------- DRAGGING (Mouse + Touch via Pointer Events) ----------
  const drag = {
    active: false,
    target: null, // "main" | "title" | "subtitle"
    startX: 0,
    startY: 0,
    origX: 0,
    origY: 0,
    pointerId: null,
  };

  function canvasPointFromEvent(ev){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    const x = (ev.clientX - rect.left) * sx;
    const y = (ev.clientY - rect.top) * sy;
    return { x, y };
  }

  function beginDrag(target, x, y, pointerId){
    drag.active = true;
    drag.target = target;
    drag.startX = x;
    drag.startY = y;
    drag.pointerId = pointerId;

    if (target === "main"){
      drag.origX = state.main.centerX;
      drag.origY = state.main.centerY;
    } else if (target === "title"){
      drag.origX = state.title.centerX;
      drag.origY = state.title.centerY;
    } else if (target === "subtitle"){
      drag.origX = state.subtitle.centerX;
      drag.origY = state.subtitle.centerY;
    }
  }

  function updateDrag(x, y){
    if (!drag.active || !drag.target) return;
    const dx = x - drag.startX;
    const dy = y - drag.startY;

    if (drag.target === "main"){
      state.main.centerX = drag.origX + dx;
      state.main.centerY = drag.origY + dy;
    } else if (drag.target === "title"){
      state.title.centerX = drag.origX + dx;
      state.title.centerY = drag.origY + dy;
    } else if (drag.target === "subtitle"){
      state.subtitle.centerX = drag.origX + dx;
      state.subtitle.centerY = drag.origY + dy;
    }
    render();
  }

  function endDrag(){
    drag.active = false;
    drag.target = null;
    drag.pointerId = null;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    ev.preventDefault();
    const p = canvasPointFromEvent(ev);
    const t = hitTest(p.x, p.y);
    if (!t) return;

    canvas.setPointerCapture(ev.pointerId);
    beginDrag(t, p.x, p.y, ev.pointerId);
  }, { passive: false });

  canvas.addEventListener("pointermove", (ev) => {
    if (!drag.active) return;
    if (drag.pointerId !== null && ev.pointerId !== drag.pointerId) return;
    ev.preventDefault();
    const p = canvasPointFromEvent(ev);
    updateDrag(p.x, p.y);
  }, { passive: false });

  canvas.addEventListener("pointerup", (ev) => {
    if (drag.pointerId !== null && ev.pointerId !== drag.pointerId) return;
    ev.preventDefault();
    endDrag();
  }, { passive: false });

  canvas.addEventListener("pointercancel", (ev) => {
    if (drag.pointerId !== null && ev.pointerId !== drag.pointerId) return;
    endDrag();
  });

  // ---------- UI BINDINGS ----------
  function bind(){
    // Background
    bgFit.addEventListener("change", () => {
      state.bg.fit = bgFit.value;
      render();
    });

    bgTransparency.addEventListener("input", () => {
      state.bg.transparencyPct = Number(bgTransparency.value);
      bgTVal.textContent = String(state.bg.transparencyPct);
      render();
    });

    bgFile.addEventListener("change", async () => {
      const f = bgFile.files && bgFile.files[0];
      if (!f) return;
      try{
        const img = await loadImageFromFile(f);
        state.bg.img = img;

        // If auto or background mode, update canvas size
        syncCanvasSizeFromMode();
        smartAutoFitAll();
        render();
      } catch (e){
        alert("Background image failed to load.");
      } finally {
        bgFile.value = "";
      }
    });

    btnClearBg.addEventListener("click", () => {
      state.bg.img = null;
      render();
    });

    // Canvas
    canvasMode.addEventListener("change", () => {
      state.canvas.mode = canvasMode.value;
      syncCanvasSizeFromMode();
    });

    btnApplyCanvas.addEventListener("click", () => {
      state.canvas.mode = canvasMode.value;
      if (state.canvas.mode !== "custom"){
        // Switch to custom if user wants to force values
        state.canvas.mode = "custom";
        canvasMode.value = "custom";
      }
      const w = Number(canvasW.value) || state.canvas.w;
      const h = Number(canvasH.value) || state.canvas.h;
      setCanvasSize(w, h);
    });

    // Main
    mainTransparency.addEventListener("input", () => {
      state.main.transparencyPct = Number(mainTransparency.value);
      mainTVal.textContent = String(state.main.transparencyPct);
      render();
    });

    mainScale.addEventListener("input", () => {
      state.main.scalePct = Number(mainScale.value);
      mainScaleVal.textContent = String(state.main.scalePct);
      render();
    });

    mainFile.addEventListener("change", async () => {
      const f = mainFile.files && mainFile.files[0];
      if (!f) return;
      try{
        const img = await loadImageFromFile(f);
        state.main.img = img;
        state.main.naturalW = img.naturalWidth || img.width;
        state.main.naturalH = img.naturalHeight || img.height;

        // If auto or main mode, update canvas size
        syncCanvasSizeFromMode();

        // Center + fit nicely by default
        state.main.centerX = state.canvas.w / 2;
        state.main.centerY = state.canvas.h / 2;
        fitMainToCanvas();

        smartAutoFitAll();
        render();
      } catch (e){
        alert("Main image failed to load.");
      } finally {
        mainFile.value = "";
      }
    });

    btnClearMain.addEventListener("click", () => {
      state.main.img = null;
      render();
    });

    btnFitMain.addEventListener("click", () => {
      fitMainToCanvas();
    });

    // Frame
    frameColor.addEventListener("input", () => {
      state.frame.color = frameColor.value;
      render();
    });

    frameThickness.addEventListener("input", () => {
      state.frame.thickness = Number(frameThickness.value);
      frameThVal.textContent = String(state.frame.thickness);
      render();
    });

    frameRadius.addEventListener("input", () => {
      state.frame.radius = Number(frameRadius.value);
      frameRadVal.textContent = String(state.frame.radius);
      render();
    });

    // Presets
    preset.addEventListener("change", () => {
      const v = preset.value;
      if (!v) return;

      const presets = {
        "1": { t: "Joy to the world", s: "Peace begins here" },
        "2": { t: "Grace upon grace", s: "Today is a gift" },
        "3": { t: "‰∏ÄËµ∑Âä†Ê≤πÂä†Ê≤π!!!", s: "Pray for everything" },
        "4": { t: "Yes, Virginia", s: "There is a Santa Claus" },
        "5": { t: "Thankful", s: "Every moment matters" },
      };
      const p = presets[v];
      if (!p) return;

      state.title.text = p.t;
      state.subtitle.text = p.s;
      titleText.value = state.title.text;
      subtitleText.value = state.subtitle.text;

      smartAutoFitAll();
      render();
    });

    // Title
    titleText.addEventListener("input", () => {
      state.title.text = titleText.value;
      smartAutoFitAll();
      render();
    });

    titleFont.addEventListener("change", () => {
      state.title.fontFamily = titleFont.value;
      smartAutoFitAll();
      render();
    });

    titleColor.addEventListener("input", () => {
      state.title.color = titleColor.value;
      render();
    });

    function syncTitleSizeFrom(val){
      const n = clamp(Number(val) || 14, 14, 800);
      state.title.sizePt = n;
      titleSize.value = String(n);
      titleSizeNum.value = String(n);
      smartAutoFitAll();
      render();
    }
    titleSize.addEventListener("input", () => syncTitleSizeFrom(titleSize.value));
    titleSizeNum.addEventListener("input", () => syncTitleSizeFrom(titleSizeNum.value));

    titleBgColor.addEventListener("input", () => {
      state.title.bgColor = titleBgColor.value;
      render();
    });

    titleBgTransparency.addEventListener("input", () => {
      state.title.bgTransparencyPct = Number(titleBgTransparency.value);
      titleBgTVal.textContent = String(state.title.bgTransparencyPct);
      render();
    });

    titleAutoFit.addEventListener("change", () => {
      state.title.autoFit = !!titleAutoFit.checked;
      smartAutoFitAll();
      render();
    });

    // Subtitle
    subtitleText.addEventListener("input", () => {
      state.subtitle.text = subtitleText.value;
      smartAutoFitAll();
      render();
    });

    subtitleFont.addEventListener("change", () => {
      state.subtitle.fontFamily = subtitleFont.value;
      smartAutoFitAll();
      render();
    });

    subtitleColor.addEventListener("input", () => {
      state.subtitle.color = subtitleColor.value;
      render();
    });

    function syncSubtitleSizeFrom(val){
      const n = clamp(Number(val) || 14, 14, 800);
      state.subtitle.sizePt = n;
      subtitleSize.value = String(n);
      subtitleSizeNum.value = String(n);
      smartAutoFitAll();
      render();
    }
    subtitleSize.addEventListener("input", () => syncSubtitleSizeFrom(subtitleSize.value));
    subtitleSizeNum.addEventListener("input", () => syncSubtitleSizeFrom(subtitleSizeNum.value));

    subtitleBgColor.addEventListener("input", () => {
      state.subtitle.bgColor = subtitleBgColor.value;
      render();
    });

    subtitleBgTransparency.addEventListener("input", () => {
      state.subtitle.bgTransparencyPct = Number(subtitleBgTransparency.value);
      subtitleBgTVal.textContent = String(state.subtitle.bgTransparencyPct);
      render();
    });

    subtitleAutoFit.addEventListener("change", () => {
      state.subtitle.autoFit = !!subtitleAutoFit.checked;
      smartAutoFitAll();
      render();
    });

    // Top buttons
    btnCenter.addEventListener("click", () => autoCenterAll());
    btnExport.addEventListener("click", () => exportPNG());
    btnRandom.addEventListener("click", () => randomStyle());

    // Reset
    btnResetAll.addEventListener("click", () => {
      if (!confirm("Reset everything to defaults?")) return;
      resetAll();
    });

    // Keep labels synced
    frameThVal.textContent = String(state.frame.thickness);
    frameRadVal.textContent = String(state.frame.radius);
    bgTVal.textContent = String(state.bg.transparencyPct);
    mainTVal.textContent = String(state.main.transparencyPct);
    mainScaleVal.textContent = String(state.main.scalePct);
    titleBgTVal.textContent = String(state.title.bgTransparencyPct);
    subtitleBgTVal.textContent = String(state.subtitle.bgTransparencyPct);
  }

  // ---------- RANDOM STYLE (Browser-only) ----------
  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
  function randHex(){
    const n = randInt(0, 0xFFFFFF);
    return "#" + n.toString(16).padStart(6,"0");
  }
  function randomPick(arr){ return arr[randInt(0, arr.length-1)]; }

  function randomStyle(){
    // Random fonts from provided list (kept)
    state.title.fontFamily = randomPick(FONT_ITEMS).value;
    state.subtitle.fontFamily = randomPick(FONT_ITEMS).value;
    titleFont.value = state.title.fontFamily;
    subtitleFont.value = state.subtitle.fontFamily;

    // Sizes (smart-ish)
    state.title.sizePt = clamp(randInt(44, 160), 14, 800);
    state.subtitle.sizePt = clamp(randInt(24, 96), 14, 800);
    titleSize.value = String(state.title.sizePt);
    titleSizeNum.value = String(state.title.sizePt);
    subtitleSize.value = String(state.subtitle.sizePt);
    subtitleSizeNum.value = String(state.subtitle.sizePt);

    // Colors
    state.frame.color = randHex();
    frameColor.value = state.frame.color;

    state.title.color = randHex();
    titleColor.value = state.title.color;

    state.subtitle.color = randHex();
    subtitleColor.value = state.subtitle.color;

    // Text backgrounds
    state.title.bgColor = randHex();
    titleBgColor.value = state.title.bgColor;
    state.subtitle.bgColor = randHex();
    subtitleBgColor.value = state.subtitle.bgColor;

    state.title.bgTransparencyPct = randInt(20, 85);
    titleBgTransparency.value = String(state.title.bgTransparencyPct);
    titleBgTVal.textContent = String(state.title.bgTransparencyPct);

    state.subtitle.bgTransparencyPct = randInt(20, 85);
    subtitleBgTransparency.value = String(state.subtitle.bgTransparencyPct);
    subtitleBgTVal.textContent = String(state.subtitle.bgTransparencyPct);

    // Frame thickness & radius
    state.frame.thickness = randInt(6, 42);
    frameThickness.value = String(state.frame.thickness);
    frameThVal.textContent = String(state.frame.thickness);

    state.frame.radius = randInt(0, 46);
    frameRadius.value = String(state.frame.radius);
    frameRadVal.textContent = String(state.frame.radius);

    // Image transparency
    state.bg.transparencyPct = randInt(20, 70);
    bgTransparency.value = String(state.bg.transparencyPct);
    bgTVal.textContent = String(state.bg.transparencyPct);

    state.main.transparencyPct = randInt(20, 70);
    mainTransparency.value = String(state.main.transparencyPct);
    mainTVal.textContent = String(state.main.transparencyPct);

    // Positions
    autoCenterAll();
    render();
  }

  // ---------- RESET ----------
  function resetAll(){
    state.canvas.mode = "auto";
    canvasMode.value = "auto";

    state.bg.img = null;
    state.bg.fit = "cover";
    bgFit.value = "cover";
    state.bg.transparencyPct = 20;
    bgTransparency.value = "20";
    bgTVal.textContent = "20";

    state.main.img = null;
    state.main.scalePct = 100;
    mainScale.value = "100";
    mainScaleVal.textContent = "100";
    state.main.transparencyPct = 20;
    mainTransparency.value = "20";
    mainTVal.textContent = "20";

    state.frame.color = "#ffffff";
    frameColor.value = "#ffffff";
    state.frame.thickness = 18;
    frameThickness.value = "18";
    frameThVal.textContent = "18";
    state.frame.radius = 18;
    frameRadius.value = "18";
    frameRadVal.textContent = "18";

    state.title.text = "Merry Christmas";
    titleText.value = state.title.text;
    state.title.fontFamily = FONT_ITEMS[0].value;
    titleFont.value = state.title.fontFamily;
    state.title.sizePt = 86;
    titleSize.value = "86";
    titleSizeNum.value = "86";
    state.title.color = "#ffffff";
    titleColor.value = "#ffffff";
    state.title.bgColor = "#000000";
    titleBgColor.value = "#000000";
    state.title.bgTransparencyPct = 55;
    titleBgTransparency.value = "55";
    titleBgTVal.textContent = "55";
    state.title.autoFit = true;
    titleAutoFit.checked = true;

    state.subtitle.text = "Peace ‚Ä¢ Joy ‚Ä¢ Hope";
    subtitleText.value = state.subtitle.text;
    state.subtitle.fontFamily = FONT_ITEMS[0].value;
    subtitleFont.value = state.subtitle.fontFamily;
    state.subtitle.sizePt = 42;
    subtitleSize.value = "42";
    subtitleSizeNum.value = "42";
    state.subtitle.color = "#ffffff";
    subtitleColor.value = "#ffffff";
    state.subtitle.bgColor = "#000000";
    subtitleBgColor.value = "#000000";
    state.subtitle.bgTransparencyPct = 65;
    subtitleBgTransparency.value = "65";
    subtitleBgTVal.textContent = "65";
    state.subtitle.autoFit = true;
    subtitleAutoFit.checked = true;

    // default canvas size
    setCanvasSize(1000, 600);
    autoCenterAll();
    render();
  }

  // ---------- INIT ----------
  function init(){
    // Defaults
    state.canvas.mode = "auto";
    canvasMode.value = "auto";

    // Set default font selections to the "Primary" option
    titleFont.value = state.title.fontFamily;
    subtitleFont.value = state.subtitle.fontFamily;

    // Initialize canvas inputs and size
    canvasW.value = String(state.canvas.w);
    canvasH.value = String(state.canvas.h);
    setCanvasSize(state.canvas.w, state.canvas.h);

    // Fill UI from state
    bgFit.value = state.bg.fit;
    bgTransparency.value = String(state.bg.transparencyPct);
    bgTVal.textContent = String(state.bg.transparencyPct);

    mainTransparency.value = String(state.main.transparencyPct);
    mainTVal.textContent = String(state.main.transparencyPct);
    mainScale.value = String(state.main.scalePct);
    mainScaleVal.textContent = String(state.main.scalePct);

    frameColor.value = state.frame.color;
    frameThickness.value = String(state.frame.thickness);
    frameThVal.textContent = String(state.frame.thickness);
    frameRadius.value = String(state.frame.radius);
    frameRadVal.textContent = String(state.frame.radius);

    titleText.value = state.title.text;
    titleColor.value = state.title.color;
    titleSize.value = String(state.title.sizePt);
    titleSizeNum.value = String(state.title.sizePt);
    titleBgColor.value = state.title.bgColor;
    titleBgTransparency.value = String(state.title.bgTransparencyPct);
    titleBgTVal.textContent = String(state.title.bgTransparencyPct);
    titleAutoFit.checked = state.title.autoFit;

    subtitleText.value = state.subtitle.text;
    subtitleColor.value = state.subtitle.color;
    subtitleSize.value = String(state.subtitle.sizePt);
    subtitleSizeNum.value = String(state.subtitle.sizePt);
    subtitleBgColor.value = state.subtitle.bgColor;
    subtitleBgTransparency.value = String(state.subtitle.bgTransparencyPct);
    subtitleBgTVal.textContent = String(state.subtitle.bgTransparencyPct);
    subtitleAutoFit.checked = state.subtitle.autoFit;

    bind();
    autoCenterAll();
    render();
  }

  init();
})();
</script>
</body>
</html>
