<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AI Image Frame Tool — 2025-12-30 22:09:38</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#101a36;
      --text:#e9eefc;
      --muted:#aab6da;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --shadow2: 0 6px 16px rgba(0,0,0,.25);
      --radius:16px;
      --radius2:12px;
      --accent:#7aa2ff;
      --danger:#ff6b6b;
      --ok:#51d88a;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 20% 10%, rgba(122,162,255,.18), transparent 50%),
                  radial-gradient(900px 600px at 90% 20%, rgba(81,216,138,.12), transparent 55%),
                  linear-gradient(180deg, #070a14, var(--bg));
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang TC","Heiti TC", sans-serif;
      min-height:100vh;
    }
    header{
      padding: 18px 18px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .titlewrap{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width: 0;
    }
    h1{
      margin:0;
      font-size: clamp(16px, 2.2vw, 22px);
      letter-spacing:.2px;
      font-weight: 750;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .subnote{
      margin:0;
      color:var(--muted);
      font-size: 12px;
      line-height: 1.35;
      max-width: 70ch;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      box-shadow: var(--shadow2);
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .dot{
      width:8px; height:8px; border-radius:999px;
      background: var(--ok);
      box-shadow: 0 0 0 6px rgba(81,216,138,.12);
    }

    main{
      max-width: 1400px;
      margin: 0 auto;
      padding: 10px 12px 22px;
    }

    /* 3-column layout: left controls, canvas, right controls */
    .layout{
      display:grid;
      grid-template-columns: minmax(270px, 340px) minmax(320px, 1fr) minmax(270px, 340px);
      gap: 14px;
      align-items: start;
    }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.04));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .ph{
      padding: 12px 14px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background: rgba(0,0,0,.18);
    }
    .panel .ph h2{
      margin:0;
      font-size: 13px;
      letter-spacing:.35px;
      text-transform: uppercase;
      color: rgba(233,238,252,.92);
    }
    .panel .pc{
      padding: 12px 14px 14px;
    }

    .group{
      padding: 10px 10px 12px;
      border:1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(0,0,0,.14);
      margin-bottom: 12px;
    }
    .group:last-child{ margin-bottom: 0; }
    .group .gh{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 8px;
      gap:10px;
    }
    .group .gh .label{
      font-size: 12px;
      color: rgba(233,238,252,.9);
      font-weight: 700;
      letter-spacing:.2px;
    }
    .hint{
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
      margin-top: 6px;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: end;
      margin-top: 10px;
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items: end;
      margin-top: 10px;
    }
    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
    }
    input[type="file"]{
      width: 100%;
      color: var(--muted);
    }
    input[type="text"], input[type="number"], select{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    input[type="text"]::placeholder{ color: rgba(170,182,218,.7); }
    input[type="range"]{ width:100%; }
    input[type="color"]{
      width:100%;
      height: 38px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      padding: 4px;
    }

    .btnrow{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 700;
      letter-spacing:.2px;
      box-shadow: 0 10px 20px rgba(0,0,0,.22);
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:active{ transform: translateY(1px); }
    .primary{
      border-color: rgba(122,162,255,.40);
      background: rgba(122,162,255,.18);
    }
    .primary:hover{ background: rgba(122,162,255,.24); }
    .danger{
      border-color: rgba(255,107,107,.40);
      background: rgba(255,107,107,.14);
    }
    .danger:hover{ background: rgba(255,107,107,.20); }
    .mini{
      padding: 8px 10px;
      font-size: 12px;
      border-radius: 10px;
      box-shadow: none;
    }

    /* Canvas area */
    .canvaspanel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 520px;
    }
    .canvashead{
      padding: 12px 14px;
      border-bottom:1px solid var(--border);
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .canvashead .left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 0;
    }
    .canvashead .ct{
      font-size: 13px;
      font-weight: 800;
      letter-spacing:.2px;
      margin:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .canvashead .cs{
      font-size: 11px;
      color: var(--muted);
      margin:0;
    }
    .canvaswrap{
      padding: 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex: 1;
    }
    .stage{
      width: 100%;
      max-width: 820px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      padding: 12px;
    }
    canvas{
      display:block;
      width: 100%;
      height: auto;
      border-radius: 14px;
      background: #0a0f1f;
      touch-action: none; /* critical for touch dragging */
    }
    .statusbar{
      padding: 10px 14px 12px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background: rgba(0,0,0,.15);
      flex-wrap: wrap;
    }
    .status{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .kbd{
      font-size: 11px;
      color: rgba(233,238,252,.78);
      padding: 4px 8px;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      background: rgba(255,255,255,.06);
    }

    /* Responsive: stack panels on smaller screens */
    @media (max-width: 1060px){
      .layout{
        grid-template-columns: 1fr;
      }
      header{
        flex-direction:column;
        align-items:flex-start;
      }
      .badge{ align-self:flex-end; }
      .canvaspanel{ min-height: 460px; }
      .stage{ max-width: 980px; }
    }
  </style>
</head>
<body>
<header>
  <div class="titlewrap">
    <h1 id="toolTitle">AI Image Frame Tool — 2025-12-30 22:09:38</h1>
    <p class="subnote">
      Layer order is locked: <b>Background → Main → Frame → Title → Subtitle</b>.
      Drag <b>Main (with Frame)</b>, <b>Title</b>, and <b>Subtitle</b> directly on the canvas (mouse + touch).
      Exported PNG matches the canvas exactly.
    </p>
  </div>
  <div class="badge" title="Browser-only / No backend / Safari + Chrome">
    <span class="dot"></span>
    <span>Browser-only • Safari-safe • Canvas Export PNG</span>
  </div>
</header>

<main>
  <div class="layout">
    <!-- LEFT CONTROLS -->
    <section class="panel">
      <div class="ph"><h2>Left Controls</h2></div>
      <div class="pc">
        <div class="group">
          <div class="gh">
            <div class="label">Canvas Size</div>
            <button id="btnAutoCenterAll" class="mini">Auto-Center</button>
          </div>

          <div class="row">
            <label>
              Base Mode
              <select id="canvasBaseMode">
                <option value="auto">Auto (Main → Background)</option>
                <option value="main">Match Main Image</option>
                <option value="bg">Match Background Image</option>
                <option value="preset">Preset</option>
                <option value="custom">Custom</option>
              </select>
            </label>
            <label>
              Preset
              <select id="canvasPreset">
                <option value="1080x1080">1080 × 1080 (Square)</option>
                <option value="1920x1080">1920 × 1080 (16:9)</option>
                <option value="1080x1350">1080 × 1350 (4:5)</option>
                <option value="2048x1536">2048 × 1536 (4:3)</option>
              </select>
            </label>
          </div>

          <div class="row">
            <label>
              Width (px)
              <input id="canvasW" type="number" min="64" step="1" value="1080" />
            </label>
            <label>
              Height (px)
              <input id="canvasH" type="number" min="64" step="1" value="1080" />
            </label>
          </div>

          <div class="hint">Tip: Use <b>Auto</b> if you want the canvas to follow your uploads automatically.</div>
        </div>

        <div class="group">
          <div class="gh">
            <div class="label">Background Image Layer</div>
            <span class="kbd">Not draggable</span>
          </div>

          <label>
            Load Background (e.g., Christmas theme)
            <input id="bgFile" type="file" accept="image/*" />
          </label>

          <div class="row">
            <label>
              Fit Mode
              <select id="bgFit">
                <option value="cover">Cover (fill canvas)</option>
                <option value="contain">Contain (fit inside)</option>
              </select>
            </label>
            <label>
              Background Opacity (20% → 100%)
              <input id="bgOpacity" type="range" min="20" max="100" value="100" />
            </label>
          </div>

          <div class="btnrow">
            <button id="btnClearBg" class="mini danger">Clear Background</button>
          </div>

          <div class="hint">Background fills the entire canvas and respects opacity. Export includes it exactly.</div>
        </div>

        <div class="group">
          <div class="gh">
            <div class="label">AI-like Enhancements</div>
          </div>

          <label>
            Preset Inspirational Captions
            <select id="captionPreset">
              <option value="">(Select a preset…)</option>
              <option value="Merry Christmas!&#10;Joy to the world.">Merry Christmas / Joy</option>
              <option value="Peace • Hope • Love">Peace • Hope • Love</option>
              <option value="感恩的心，常常喜樂">感恩的心 / 常常喜樂</option>
              <option value="一起加油加油!!!">一起加油加油!!!</option>
              <option value="Yes, Virginia, there is a Santa Claus.">Yes, Virginia…</option>
              <option value="Pray for everything.&#10;Don’t worry for anything.">Pray / Don’t worry</option>
            </select>
          </label>

          <div class="btnrow">
            <button id="btnRandomStyle" class="mini primary">Random Style</button>
            <button id="btnSmartText" class="mini">Smart Text Size</button>
          </div>

          <div class="hint">Random Style changes font/size/color (Title & Subtitle). Smart Text Size picks readable defaults.</div>
        </div>
      </div>
    </section>

    <!-- CANVAS PREVIEW (CENTER) -->
    <section class="canvaspanel">
      <div class="canvashead">
        <div class="left">
          <p class="ct">Canvas Preview</p>
          <p class="cs" id="canvasMeta">1080 × 1080 px</p>
        </div>
        <div class="btnrow" style="margin:0;">
          <button id="btnDownload" class="mini primary">Download PNG</button>
          <button id="btnResetAll" class="mini danger">Reset</button>
        </div>
      </div>

      <div class="canvaswrap">
        <div class="stage">
          <canvas id="c" width="1080" height="1080" aria-label="Canvas preview"></canvas>
        </div>
      </div>

      <div class="statusbar">
        <div class="status" id="statusText">Load images to begin. Drag Main/Title/Subtitle on canvas.</div>
        <div class="status">
          <span class="kbd">Drag:</span>
          <span class="kbd">Main+Frame</span>
          <span class="kbd">Title</span>
          <span class="kbd">Subtitle</span>
        </div>
      </div>
    </section>

    <!-- RIGHT CONTROLS -->
    <section class="panel">
      <div class="ph"><h2>Right Controls</h2></div>
      <div class="pc">

        <div class="group">
          <div class="gh">
            <div class="label">Main Image Layer (Foreground)</div>
            <span class="kbd">Draggable</span>
          </div>

          <label>
            Load Main Image (photo / portrait)
            <input id="mainFile" type="file" accept="image/*" />
          </label>

          <div class="row">
            <label>
              Main Opacity (20% → 100%)
              <input id="mainOpacity" type="range" min="20" max="100" value="100" />
            </label>
            <label>
              Main Scale (10% → 200%)
              <input id="mainScale" type="range" min="10" max="200" value="100" />
            </label>
          </div>

          <div class="row">
            <button id="btnClearMain" class="mini danger">Clear Main</button>
            <button id="btnCenterMain" class="mini">Center Main</button>
          </div>

          <div class="hint">Main image keeps aspect ratio. Frame always wraps the displayed main image and moves together.</div>
        </div>

        <div class="group">
          <div class="gh">
            <div class="label">Frame / Border (wraps Main only)</div>
          </div>

          <div class="row">
            <label>
              Frame Color
              <input id="frameColor" type="color" value="#ffffff" />
            </label>
            <label>
              Frame Thickness (px)
              <input id="frameThickness" type="range" min="0" max="200" value="24" />
            </label>
          </div>

          <div class="hint">Thickness is uniform on all sides. Frame is rendered above main image, below text layers.</div>
        </div>

        <div class="group">
          <div class="gh">
            <div class="label">Title Text Layer</div>
            <span class="kbd">Draggable</span>
          </div>

          <label>
            Title Text (real-time)
            <input id="titleText" type="text" placeholder="Enter title…" value="Merry Christmas!" />
          </label>

          <div class="row">
            <label>
              Title Font Family
              <select id="titleFont"></select>
            </label>
            <label>
              Title Color
              <input id="titleColor" type="color" value="#ffffff" />
            </label>
          </div>

          <div class="row">
            <label>
              Title Size (14pt → 800pt)
              <input id="titleSize" type="range" min="14" max="800" value="84" />
            </label>
            <label>
              Title Size (pt)
              <input id="titleSizeN" type="number" min="14" max="800" value="84" />
            </label>
          </div>

          <div class="btnrow">
            <button id="btnTitleCenter" class="mini">Center Title</button>
            <button id="btnClearTitle" class="mini danger">Clear</button>
          </div>
        </div>

        <div class="group">
          <div class="gh">
            <div class="label">Subtitle Text Layer</div>
            <span class="kbd">Draggable</span>
          </div>

          <label>
            Subtitle Text (real-time)
            <input id="subtitleText" type="text" placeholder="Enter subtitle…" value="Peace • Hope • Love" />
          </label>

          <div class="row">
            <label>
              Subtitle Font Family
              <select id="subtitleFont"></select>
            </label>
            <label>
              Subtitle Color
              <input id="subtitleColor" type="color" value="#aab6da" />
            </label>
          </div>

          <div class="row">
            <label>
              Subtitle Size (14pt → 800pt)
              <input id="subtitleSize" type="range" min="14" max="800" value="48" />
            </label>
            <label>
              Subtitle Size (pt)
              <input id="subtitleSizeN" type="number" min="14" max="800" value="48" />
            </label>
          </div>

          <div class="btnrow">
            <button id="btnSubtitleCenter" class="mini">Center Subtitle</button>
            <button id="btnClearSubtitle" class="mini danger">Clear</button>
          </div>
        </div>

      </div>
    </section>
  </div>
</main>

<script>
/* =========================
   Version Identification
   ========================= */
(function initTimestamp(){
  // Keep the hardcoded generation timestamp (for the HTML <title> tag requirement),
  // and also set a runtime-confirmed timestamp if desired.
  // We DO NOT replace it with "now" to avoid mismatch with the required format in <title>.
  const ts = "2025-12-30 22:09:38";
  const full = "AI Image Frame Tool — " + ts;
  document.title = full;
  const h = document.getElementById("toolTitle");
  if (h) h.textContent = full;
})();

/* =========================
   Safari-safe image loading
   (FileReader -> HTMLImageElement)
   ========================= */
function loadImageFromFile(file){
  return new Promise((resolve, reject) => {
    if (!file) return reject(new Error("No file."));
    const reader = new FileReader();
    reader.onerror = () => reject(new Error("Failed to read file."));
    reader.onload = () => {
      const img = new Image();
      // Local files: no crossOrigin needed.
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error("Failed to decode image."));
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
  });
}

/* =========================
   Canvas + State
   Layer order is LOCKED:
   Background -> Main -> Frame -> Title -> Subtitle
   ========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: true });

const statusText = document.getElementById("statusText");
const canvasMeta = document.getElementById("canvasMeta");

const state = {
  bg: { img: null, opacity: 1.0, fit: "cover" },
  main: { img: null, opacity: 1.0, scale: 1.0, cx: canvas.width/2, cy: canvas.height/2 },
  frame: { color: "#ffffff", thickness: 24 },
  title: { text: "Merry Christmas!", color: "#ffffff", size: 84, font: "", x: canvas.width/2, y: canvas.height*0.18 },
  subtitle: { text: "Peace • Hope • Love", color: "#aab6da", size: 48, font: "", x: canvas.width/2, y: canvas.height*0.28 },
  drag: { active: false, target: null, dx: 0, dy: 0 },
  lastRenderInfo: ""
};

/* =========================
   Font options (MANDATORY ORDER)
   Must remain available for BOTH Title & Subtitle.
   ========================= */
const FONT_OPTIONS = [
  // Traditional Chinese (繁體中文) — order MUST match exactly:
  { label: "PingFang TC（蘋方-繁）— ⭐ Primary", value: "\"PingFang TC\",\"PingFangTC-Regular\",\"PingFangTC-Medium\",\"PingFangTC-Semibold\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "PingFang TC", value: "\"PingFang TC\",\"PingFangTC-Regular\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "PingFangTC-Regular", value: "\"PingFangTC-Regular\",\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "PingFangTC-Medium", value: "\"PingFangTC-Medium\",\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "PingFangTC-Semibold", value: "\"PingFangTC-Semibold\",\"PingFang TC\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "Heiti TC（黑體-繁）", value: "\"Heiti TC\",\"Heiti TC Medium\",\"Heiti TC Light\",system-ui,sans-serif" },
  { label: "Heiti TC", value: "\"Heiti TC\",\"Heiti TC Medium\",\"Heiti TC Light\",system-ui,sans-serif" },
  { label: "Heiti TC Light", value: "\"Heiti TC Light\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "Heiti TC Medium", value: "\"Heiti TC Medium\",\"Heiti TC\",system-ui,sans-serif" },
  { label: "Songti TC（宋體-繁）", value: "\"Songti TC\",\"Songti TC Regular\",\"Songti TC Bold\",serif" },
  { label: "Songti TC", value: "\"Songti TC\",\"Songti TC Regular\",serif" },
  { label: "Songti TC Regular", value: "\"Songti TC Regular\",\"Songti TC\",serif" },
  { label: "Songti TC Bold", value: "\"Songti TC Bold\",\"Songti TC\",serif" },
  { label: "Kaiti TC（楷體-繁）", value: "\"Kaiti TC\",\"Songti TC\",serif" },
  { label: "Kaiti TC", value: "\"Kaiti TC\",\"Songti TC\",serif" },

  // Latin / System Fonts
  { label: "system-ui", value: "system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif" },
  { label: "Arial", value: "Arial,system-ui,sans-serif" },
  { label: "Helvetica", value: "Helvetica,Arial,system-ui,sans-serif" },
];

function buildFontSelect(selectEl){
  selectEl.innerHTML = "";
  for (const opt of FONT_OPTIONS){
    const o = document.createElement("option");
    o.value = opt.value;
    o.textContent = opt.label;
    selectEl.appendChild(o);
  }
}

/* =========================
   Geometry helpers
   ========================= */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function getMainRect(){
  const img = state.main.img;
  if (!img) return null;
  const w = img.naturalWidth * state.main.scale;
  const h = img.naturalHeight * state.main.scale;
  return { x: state.main.cx - w/2, y: state.main.cy - h/2, w, h };
}

function measureTextBox(text, fontFamily, sizePt){
  // sizePt is used as pixels for canvas text (pt-like control). We treat 1pt ≈ 1px for simplicity.
  const lines = String(text || "").split("\n");
  const size = Math.max(1, Number(sizePt) || 1);
  ctx.save();
  ctx.font = `${Math.round(size)}px ${fontFamily}`;
  let maxW = 0;
  for (const line of lines){
    const w = ctx.measureText(line).width;
    if (w > maxW) maxW = w;
  }
  ctx.restore();
  const lineH = size * 1.18;
  const h = lines.length * lineH;
  return { w: maxW, h, lines, lineH };
}

function hitTestText(layerKey, mx, my){
  const layer = state[layerKey];
  const box = measureTextBox(layer.text, layer.font, layer.size);
  const padX = 10, padY = 8;
  const x0 = layer.x - (box.w/2) - padX;
  const y0 = layer.y - (box.h/2) - padY;
  const w = box.w + padX*2;
  const h = box.h + padY*2;
  const hit = (mx >= x0 && mx <= x0+w && my >= y0 && my <= y0+h);
  return hit ? { x0, y0, w, h } : null;
}

function hitTestMain(mx, my){
  const r = getMainRect();
  if (!r) return null;
  const t = state.frame.thickness;
  // include frame thickness area for easier grabbing
  const pad = Math.max(8, t/2);
  const x0 = r.x - pad;
  const y0 = r.y - pad;
  const w  = r.w + pad*2;
  const h  = r.h + pad*2;
  const hit = (mx >= x0 && mx <= x0+w && my >= y0 && my <= y0+h);
  return hit ? { x0, y0, w, h, rect: r } : null;
}

/* =========================
   Rendering
   ========================= */
function clearCanvas(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function drawBackground(){
  const { img, opacity, fit } = state.bg;
  if (!img) return;

  ctx.save();
  ctx.globalAlpha = clamp(opacity, 0, 1);

  const cw = canvas.width, ch = canvas.height;
  const iw = img.naturalWidth, ih = img.naturalHeight;

  // contain/cover fit while preserving aspect ratio
  const scale = (fit === "contain")
    ? Math.min(cw / iw, ch / ih)
    : Math.max(cw / iw, ch / ih);

  const dw = iw * scale;
  const dh = ih * scale;
  const dx = (cw - dw) / 2;
  const dy = (ch - dh) / 2;

  ctx.drawImage(img, dx, dy, dw, dh);
  ctx.restore();
}

function drawMain(){
  const { img, opacity, scale, cx, cy } = state.main;
  if (!img) return;

  const w = img.naturalWidth * scale;
  const h = img.naturalHeight * scale;
  const x = cx - w/2;
  const y = cy - h/2;

  ctx.save();
  ctx.globalAlpha = clamp(opacity, 0, 1);
  ctx.drawImage(img, x, y, w, h);
  ctx.restore();
}

function drawFrame(){
  const r = getMainRect();
  if (!r) return;

  const t = Math.max(0, Number(state.frame.thickness) || 0);
  if (t <= 0) return;

  ctx.save();
  ctx.strokeStyle = state.frame.color;
  ctx.lineWidth = t;
  ctx.globalAlpha = 1.0;

  // Stroke is centered on the rect path. We'll align to half-pixel when possible.
  const half = t / 2;
  ctx.strokeRect(r.x - half, r.y - half, r.w + t, r.h + t);

  // subtle inner highlight for a nicer frame (still Canvas-only)
  ctx.globalAlpha = 0.25;
  ctx.lineWidth = Math.max(1, t * 0.15);
  ctx.strokeStyle = "#ffffff";
  const inset = Math.max(1, t * 0.35);
  ctx.strokeRect(r.x + inset, r.y + inset, r.w - inset*2, r.h - inset*2);

  ctx.restore();
}

function drawTextLayer(key){
  const layer = state[key];
  if (!layer.text) return;

  const size = clamp(Number(layer.size) || 14, 14, 800);
  const fontFamily = layer.font || "system-ui,sans-serif";
  const box = measureTextBox(layer.text, fontFamily, size);

  ctx.save();
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = layer.color;
  ctx.font = `${Math.round(size)}px ${fontFamily}`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  // draw each line centered around layer.y
  const totalH = box.h;
  let y = layer.y - totalH/2 + box.lineH/2;
  for (const line of box.lines){
    ctx.fillText(line, layer.x, y);
    y += box.lineH;
  }

  ctx.restore();
}

function render(){
  clearCanvas();

  // Locked layer order:
  drawBackground();      // 1) Background Image Layer
  drawMain();            // 2) Main Image Layer
  drawFrame();           // 3) Frame / Border Layer
  drawTextLayer("title");// 4) Title Text Layer
  drawTextLayer("subtitle");// 5) Subtitle Text Layer

  canvasMeta.textContent = `${canvas.width} × ${canvas.height} px`;
}

/* =========================
   Smart defaults / Auto center
   ========================= */
function autoCenterAll(){
  // center main (if present)
  if (state.main.img){
    state.main.cx = canvas.width/2;
    state.main.cy = canvas.height/2;
  }
  // title/subtitle default positions
  state.title.x = canvas.width/2;
  state.subtitle.x = canvas.width/2;
  state.title.y = canvas.height * 0.18;
  state.subtitle.y = canvas.height * 0.28;
  render();
  setStatus("Auto-centered Main/Title/Subtitle.");
}

function smartMainScale(){
  const img = state.main.img;
  if (!img) return;
  // Fit main within canvas with margin
  const margin = 0.12; // 12% margin
  const maxW = canvas.width * (1 - margin*2);
  const maxH = canvas.height * (1 - margin*2);
  const s = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight);
  state.main.scale = clamp(s, 0.1, 2.0);
  syncMainScaleUI();
}

function smartTextSizes(){
  // Title bigger, subtitle smaller, based on canvas size
  const base = Math.max(14, Math.min(canvas.width, canvas.height) * 0.08);
  state.title.size = clamp(Math.round(base), 14, 800);
  state.subtitle.size = clamp(Math.round(base * 0.58), 14, 800);
  syncTextSizeUI();
  render();
  setStatus("Smart Text Size applied.");
}

/* =========================
   Canvas size logic
   ========================= */
const canvasBaseMode = document.getElementById("canvasBaseMode");
const canvasPreset = document.getElementById("canvasPreset");
const canvasW = document.getElementById("canvasW");
const canvasH = document.getElementById("canvasH");

function setCanvasSize(w, h){
  const W = clamp(Math.round(Number(w) || canvas.width), 64, 16384);
  const H = clamp(Math.round(Number(h) || canvas.height), 64, 16384);
  canvas.width = W;
  canvas.height = H;

  // Keep positions relative-ish by recentering
  autoCenterAll();

  // Update inputs
  canvasW.value = W;
  canvasH.value = H;
  render();
}

function applyCanvasPreset(){
  const v = canvasPreset.value;
  const m = /^(\d+)\s*x\s*(\d+)$/i.exec(v.replace("×","x"));
  if (m){
    setCanvasSize(+m[1], +m[2]);
  }
}

function updateCanvasFromMode(){
  const mode = canvasBaseMode.value;
  if (mode === "preset"){
    applyCanvasPreset();
    return;
  }
  if (mode === "custom"){
    setCanvasSize(canvasW.value, canvasH.value);
    return;
  }
  if (mode === "main" && state.main.img){
    setCanvasSize(state.main.img.naturalWidth, state.main.img.naturalHeight);
    return;
  }
  if (mode === "bg" && state.bg.img){
    setCanvasSize(state.bg.img.naturalWidth, state.bg.img.naturalHeight);
    return;
  }
  // auto mode
  if (mode === "auto"){
    if (state.main.img){
      setCanvasSize(state.main.img.naturalWidth, state.main.img.naturalHeight);
      return;
    }
    if (state.bg.img){
      setCanvasSize(state.bg.img.naturalWidth, state.bg.img.naturalHeight);
      return;
    }
    // nothing loaded: keep current
    setCanvasSize(canvasW.value, canvasH.value);
  }
}

/* =========================
   Dragging (mouse + touch)
   Safari-safe: pointer events when available,
   fallback to mouse/touch.
   ========================= */
function canvasPointFromEvent(ev){
  const rect = canvas.getBoundingClientRect();
  const clientX = ev.clientX;
  const clientY = ev.clientY;
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  return { x, y };
}

function startDrag(target, mx, my){
  state.drag.active = true;
  state.drag.target = target;

  if (target === "main"){
    // store delta from center
    state.drag.dx = state.main.cx - mx;
    state.drag.dy = state.main.cy - my;
    setStatus("Dragging Main + Frame…");
  } else if (target === "title"){
    state.drag.dx = state.title.x - mx;
    state.drag.dy = state.title.y - my;
    setStatus("Dragging Title…");
  } else if (target === "subtitle"){
    state.drag.dx = state.subtitle.x - mx;
    state.drag.dy = state.subtitle.y - my;
    setStatus("Dragging Subtitle…");
  }
}

function moveDrag(mx, my){
  if (!state.drag.active) return;
  const t = state.drag.target;
  if (t === "main"){
    state.main.cx = mx + state.drag.dx;
    state.main.cy = my + state.drag.dy;
  } else if (t === "title"){
    state.title.x = mx + state.drag.dx;
    state.title.y = my + state.drag.dy;
  } else if (t === "subtitle"){
    state.subtitle.x = mx + state.drag.dx;
    state.subtitle.y = my + state.drag.dy;
  }
  render();
}

function endDrag(){
  if (!state.drag.active) return;
  state.drag.active = false;
  state.drag.target = null;
  setStatus("Ready.");
}

function onDown(ev){
  // Prevent page scrolling during touch drag
  if (ev.cancelable) ev.preventDefault();

  const p = canvasPointFromEvent(ev);
  // hit test order: Title, Subtitle, Main (to match typical UX)
  // (Rendering order stays locked; hit-test order is allowed.)
  const hitTitle = hitTestText("title", p.x, p.y);
  if (hitTitle){ startDrag("title", p.x, p.y); return; }

  const hitSubtitle = hitTestText("subtitle", p.x, p.y);
  if (hitSubtitle){ startDrag("subtitle", p.x, p.y); return; }

  const hitMain = hitTestMain(p.x, p.y);
  if (hitMain){ startDrag("main", p.x, p.y); return; }

  setStatus("Tip: Drag Main/Title/Subtitle directly on canvas.");
}

function onMove(ev){
  if (!state.drag.active) return;
  if (ev.cancelable) ev.preventDefault();
  const p = canvasPointFromEvent(ev);
  moveDrag(p.x, p.y);
}

function onUp(ev){
  if (ev && ev.cancelable) ev.preventDefault();
  endDrag();
}

function bindDragEvents(){
  const usePointer = ("PointerEvent" in window);
  if (usePointer){
    canvas.addEventListener("pointerdown", (e) => { canvas.setPointerCapture(e.pointerId); onDown(e); });
    canvas.addEventListener("pointermove", onMove);
    canvas.addEventListener("pointerup", onUp);
    canvas.addEventListener("pointercancel", onUp);
  } else {
    // Mouse
    canvas.addEventListener("mousedown", (e) => {
      onDown(e);
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", (ev) => {
        onUp(ev);
        window.removeEventListener("mousemove", onMove);
      }, { once:true });
    });
    // Touch
    canvas.addEventListener("touchstart", (e) => {
      const t = e.touches[0];
      onDown({ clientX: t.clientX, clientY: t.clientY, preventDefault: () => e.preventDefault(), cancelable: true });
    }, { passive:false });
    canvas.addEventListener("touchmove", (e) => {
      if (!state.drag.active) return;
      const t = e.touches[0];
      onMove({ clientX: t.clientX, clientY: t.clientY, preventDefault: () => e.preventDefault(), cancelable: true });
    }, { passive:false });
    canvas.addEventListener("touchend", (e) => onUp({ preventDefault: () => e.preventDefault(), cancelable: true }), { passive:false });
    canvas.addEventListener("touchcancel", (e) => onUp({ preventDefault: () => e.preventDefault(), cancelable: true }), { passive:false });
  }
}

/* =========================
   UI bindings
   ========================= */
const bgFile = document.getElementById("bgFile");
const mainFile = document.getElementById("mainFile");
const bgOpacity = document.getElementById("bgOpacity");
const mainOpacity = document.getElementById("mainOpacity");
const bgFit = document.getElementById("bgFit");
const mainScale = document.getElementById("mainScale");

const frameColor = document.getElementById("frameColor");
const frameThickness = document.getElementById("frameThickness");

const titleText = document.getElementById("titleText");
const titleFont = document.getElementById("titleFont");
const titleColor = document.getElementById("titleColor");
const titleSize = document.getElementById("titleSize");
const titleSizeN = document.getElementById("titleSizeN");

const subtitleText = document.getElementById("subtitleText");
const subtitleFont = document.getElementById("subtitleFont");
const subtitleColor = document.getElementById("subtitleColor");
const subtitleSize = document.getElementById("subtitleSize");
const subtitleSizeN = document.getElementById("subtitleSizeN");

const captionPreset = document.getElementById("captionPreset");

function setStatus(msg){
  statusText.textContent = msg;
}

function syncTextSizeUI(){
  titleSize.value = state.title.size;
  titleSizeN.value = state.title.size;
  subtitleSize.value = state.subtitle.size;
  subtitleSizeN.value = state.subtitle.size;
}

function syncMainScaleUI(){
  // mainScale is 10..200 representing 0.1..2.0
  const v = Math.round(state.main.scale * 100);
  mainScale.value = clamp(v, 10, 200);
}

function normalizeUIFromState(){
  bgOpacity.value = Math.round(state.bg.opacity * 100);
  bgFit.value = state.bg.fit;

  mainOpacity.value = Math.round(state.main.opacity * 100);
  syncMainScaleUI();

  frameColor.value = state.frame.color;
  frameThickness.value = state.frame.thickness;

  titleText.value = state.title.text;
  titleColor.value = state.title.color;
  titleSize.value = state.title.size;
  titleSizeN.value = state.title.size;

  subtitleText.value = state.subtitle.text;
  subtitleColor.value = state.subtitle.color;
  subtitleSize.value = state.subtitle.size;
  subtitleSizeN.value = state.subtitle.size;
}

/* Build font dropdowns in mandatory order */
buildFontSelect(titleFont);
buildFontSelect(subtitleFont);

// Default fonts (Primary)
titleFont.selectedIndex = 0;
subtitleFont.selectedIndex = 0;
state.title.font = titleFont.value;
state.subtitle.font = subtitleFont.value;

bgFile.addEventListener("change", async (e) => {
  try{
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    state.bg.img = await loadImageFromFile(file);

    // Apply canvas sizing depending on mode
    if (canvasBaseMode.value === "bg" || canvasBaseMode.value === "auto"){
      updateCanvasFromMode();
    } else {
      render();
    }
    setStatus("Background loaded.");
  }catch(err){
    setStatus("Background load failed (Safari-safe loader). Try another image.");
  }
});

mainFile.addEventListener("change", async (e) => {
  try{
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    state.main.img = await loadImageFromFile(file);

    // Resize canvas if auto/main modes
    if (canvasBaseMode.value === "main" || canvasBaseMode.value === "auto"){
      updateCanvasFromMode();
    } else {
      // still center main in current canvas
      state.main.cx = canvas.width/2;
      state.main.cy = canvas.height/2;
    }

    smartMainScale();
    syncMainScaleUI();
    autoCenterAll();

    setStatus("Main image loaded. Drag it (frame moves together).");
  }catch(err){
    setStatus("Main image load failed (Safari-safe loader). Try another image.");
  }
});

bgOpacity.addEventListener("input", () => {
  state.bg.opacity = clamp(Number(bgOpacity.value)/100, 0.2, 1.0);
  render();
});
mainOpacity.addEventListener("input", () => {
  state.main.opacity = clamp(Number(mainOpacity.value)/100, 0.2, 1.0);
  render();
});
bgFit.addEventListener("change", () => {
  state.bg.fit = bgFit.value;
  render();
});
mainScale.addEventListener("input", () => {
  state.main.scale = clamp(Number(mainScale.value)/100, 0.1, 2.0);
  render();
});

frameColor.addEventListener("input", () => {
  state.frame.color = frameColor.value;
  render();
});
frameThickness.addEventListener("input", () => {
  state.frame.thickness = Math.max(0, Number(frameThickness.value) || 0);
  render();
});

titleText.addEventListener("input", () => { state.title.text = titleText.value; render(); });
titleFont.addEventListener("change", () => { state.title.font = titleFont.value; render(); });
titleColor.addEventListener("input", () => { state.title.color = titleColor.value; render(); });
titleSize.addEventListener("input", () => {
  const v = clamp(Number(titleSize.value)||14, 14, 800);
  state.title.size = v;
  titleSizeN.value = v;
  render();
});
titleSizeN.addEventListener("input", () => {
  const v = clamp(Number(titleSizeN.value)||14, 14, 800);
  state.title.size = v;
  titleSize.value = v;
  render();
});

subtitleText.addEventListener("input", () => { state.subtitle.text = subtitleText.value; render(); });
subtitleFont.addEventListener("change", () => { state.subtitle.font = subtitleFont.value; render(); });
subtitleColor.addEventListener("input", () => { state.subtitle.color = subtitleColor.value; render(); });
subtitleSize.addEventListener("input", () => {
  const v = clamp(Number(subtitleSize.value)||14, 14, 800);
  state.subtitle.size = v;
  subtitleSizeN.value = v;
  render();
});
subtitleSizeN.addEventListener("input", () => {
  const v = clamp(Number(subtitleSizeN.value)||14, 14, 800);
  state.subtitle.size = v;
  subtitleSize.value = v;
  render();
});

/* Canvas size controls */
canvasBaseMode.addEventListener("change", () => updateCanvasFromMode());
canvasPreset.addEventListener("change", () => { if (canvasBaseMode.value === "preset") applyCanvasPreset(); });
canvasW.addEventListener("change", () => { if (canvasBaseMode.value === "custom") setCanvasSize(canvasW.value, canvasH.value); });
canvasH.addEventListener("change", () => { if (canvasBaseMode.value === "custom") setCanvasSize(canvasW.value, canvasH.value); });

/* Buttons */
document.getElementById("btnAutoCenterAll").addEventListener("click", autoCenterAll);

document.getElementById("btnClearBg").addEventListener("click", () => {
  state.bg.img = null;
  bgFile.value = "";
  render();
  setStatus("Background cleared.");
});
document.getElementById("btnClearMain").addEventListener("click", () => {
  state.main.img = null;
  mainFile.value = "";
  render();
  setStatus("Main cleared.");
});
document.getElementById("btnCenterMain").addEventListener("click", () => {
  if (!state.main.img) return;
  state.main.cx = canvas.width/2;
  state.main.cy = canvas.height/2;
  render();
  setStatus("Main centered.");
});

document.getElementById("btnTitleCenter").addEventListener("click", () => {
  state.title.x = canvas.width/2;
  state.title.y = canvas.height*0.18;
  render();
});
document.getElementById("btnClearTitle").addEventListener("click", () => {
  state.title.text = "";
  titleText.value = "";
  render();
});

document.getElementById("btnSubtitleCenter").addEventListener("click", () => {
  state.subtitle.x = canvas.width/2;
  state.subtitle.y = canvas.height*0.28;
  render();
});
document.getElementById("btnClearSubtitle").addEventListener("click", () => {
  state.subtitle.text = "";
  subtitleText.value = "";
  render();
});

document.getElementById("btnSmartText").addEventListener("click", () => {
  smartTextSizes();
});

document.getElementById("btnRandomStyle").addEventListener("click", () => {
  // Randomize: Title/Subtitle font, size, color; also frame color & thickness a bit
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function randColor(){
    const r = randInt(70,255), g = randInt(70,255), b = randInt(70,255);
    return "#" + [r,g,b].map(v => v.toString(16).padStart(2,"0")).join("");
  }

  const idx1 = randInt(0, FONT_OPTIONS.length-1);
  const idx2 = randInt(0, FONT_OPTIONS.length-1);
  titleFont.selectedIndex = idx1;
  subtitleFont.selectedIndex = idx2;
  state.title.font = titleFont.value;
  state.subtitle.font = subtitleFont.value;

  state.title.size = clamp(randInt(34, Math.min(240, Math.floor(Math.min(canvas.width,canvas.height)*0.25))), 14, 800);
  state.subtitle.size = clamp(randInt(22, Math.max(24, Math.floor(state.title.size*0.72))), 14, 800);

  state.title.color = randColor();
  state.subtitle.color = randColor();

  state.frame.color = randColor();
  state.frame.thickness = clamp(randInt(0, 80), 0, 200);

  // update UI
  titleColor.value = state.title.color;
  subtitleColor.value = state.subtitle.color;
  frameColor.value = state.frame.color;
  frameThickness.value = state.frame.thickness;

  syncTextSizeUI();
  render();
  setStatus("Random Style applied.");
});

/* Preset captions -> fill Title + Subtitle */
captionPreset.addEventListener("change", () => {
  const v = captionPreset.value;
  if (!v) return;
  const parts = v.split("\n");
  state.title.text = parts[0] || "";
  state.subtitle.text = parts.slice(1).join("\n") || "";
  titleText.value = state.title.text;
  subtitleText.value = state.subtitle.text;
  smartTextSizes();
  autoCenterAll();
  render();
  setStatus("Preset caption applied.");
});

/* Export PNG */
document.getElementById("btnDownload").addEventListener("click", () => {
  try{
    const a = document.createElement("a");
    a.download = "framed.png";
    a.href = canvas.toDataURL("image/png");
    document.body.appendChild(a);
    a.click();
    a.remove();
    setStatus("PNG exported.");
  }catch(err){
    setStatus("Export failed. Try again (Safari may block if not user-initiated).");
  }
});

/* Reset */
document.getElementById("btnResetAll").addEventListener("click", () => {
  state.bg.img = null;
  state.bg.opacity = 1.0;
  state.bg.fit = "cover";

  state.main.img = null;
  state.main.opacity = 1.0;
  state.main.scale = 1.0;
  state.main.cx = canvas.width/2;
  state.main.cy = canvas.height/2;

  state.frame.color = "#ffffff";
  state.frame.thickness = 24;

  state.title.text = "Merry Christmas!";
  state.title.color = "#ffffff";
  state.title.size = 84;
  state.title.font = FONT_OPTIONS[0].value;
  state.title.x = canvas.width/2;
  state.title.y = canvas.height*0.18;

  state.subtitle.text = "Peace • Hope • Love";
  state.subtitle.color = "#aab6da";
  state.subtitle.size = 48;
  state.subtitle.font = FONT_OPTIONS[0].value;
  state.subtitle.x = canvas.width/2;
  state.subtitle.y = canvas.height*0.28;

  // Reset files
  bgFile.value = "";
  mainFile.value = "";
  captionPreset.value = "";

  // Reset canvas mode to Auto and default size
  canvasBaseMode.value = "auto";
  canvasPreset.value = "1080x1080";
  canvasW.value = 1080;
  canvasH.value = 1080;
  setCanvasSize(1080, 1080);

  // Reset font selects
  titleFont.selectedIndex = 0;
  subtitleFont.selectedIndex = 0;

  normalizeUIFromState();
  render();
  setStatus("Reset done.");
});

/* Init */
function init(){
  normalizeUIFromState();
  bindDragEvents();
  render();
  setStatus("Ready. Load images, drag Main/Title/Subtitle, then export PNG.");
}
init();
</script>
</body>
</html>
