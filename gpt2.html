<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AI Image Frame Tool â€” 2025-12-30 20:59:45</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#111a2e;
      --muted:#8ea2c6;
      --text:#e9f0ff;
      --accent:#7aa8ff;
      --shadow: 0 10px 28px rgba(0,0,0,.28);
      --radius: 14px;
      --gap: 12px;
      --border: 1px solid rgba(255,255,255,.08);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 0%, rgba(122,168,255,.18), transparent 55%),
                  radial-gradient(1000px 700px at 90% 10%, rgba(154,110,255,.16), transparent 52%),
                  var(--bg);
      color:var(--text);
    }
    header{
      position:sticky;
      top:0;
      z-index:5;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(11,18,32,.72);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px 14px 18px;
    }
    h1{
      margin: 2px 0 10px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    .sub{
      margin:0 0 8px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
    }

    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: var(--gap);
    }
    .card{
      background: rgba(17,26,46,.92);
      border: var(--border);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: 12px;
      min-width: 0;
    }
    .card h2{
      margin:0 0 10px;
      font-size: 13px;
      font-weight: 750;
      color: #f3f6ff;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .badge{
      font-size: 10px;
      color: rgba(255,255,255,.82);
      background: rgba(122,168,255,.18);
      border: 1px solid rgba(122,168,255,.28);
      padding: 2px 8px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    label{
      display:flex;
      flex-direction: column;
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
      min-width: 140px;
      flex: 1 1 160px;
    }
    input[type="file"]{
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
    }
    input[type="text"], input[type="number"], select{
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      outline: none;
    }
    input[type="color"]{
      width: 100%;
      height: 38px;
      padding: 0;
      border-radius: 10px;
      background: transparent;
      border: 1px solid rgba(255,255,255,.10);
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    .inline{
      display:flex;
      gap: 8px;
      align-items: center;
    }
    .inline > *{flex:1}
    .inline .tight{flex:0 0 110px}
    .tiny{
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
      line-height: 1.3;
    }

    .btnbar{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;
      margin-top: 10px;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(122,168,255,.18);
      color: #f2f7ff;
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: .2px;
      box-shadow: 0 10px 18px rgba(0,0,0,.18);
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    button:hover{ background: rgba(122,168,255,.24); border-color: rgba(255,255,255,.22); }
    button:active{ transform: translateY(1px); }
    button.secondary{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.12);
    }
    button.danger{
      background: rgba(255,105,105,.14);
      border-color: rgba(255,105,105,.22);
    }

    .controls .card.bg { grid-column: span 4; }
    .controls .card.main { grid-column: span 4; }
    .controls .card.frame { grid-column: span 4; }
    .controls .card.title { grid-column: span 6; }
    .controls .card.subtitle { grid-column: span 6; }
    .controls .card.canvas { grid-column: span 12; }

    .canvasWrap{
      display:flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }
    .canvasTopRow{
      width: 100%;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }
    .hintPills{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }
    .pill{
      font-size: 11px;
      color: rgba(255,255,255,.86);
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      padding: 6px 10px;
      border-radius: 999px;
      user-select:none;
      -webkit-user-select:none;
      white-space: nowrap;
    }
    .canvasShell{
      width: 100%;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    canvas{
      display:block;
      width: 100%;
      height: auto;
      touch-action: none; /* critical for dragging on iOS Safari */
      background: rgba(255,255,255,.02);
    }

    .footer{
      margin-top: 10px;
      font-size: 11px;
      color: var(--muted);
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.86);
    }

    @media (max-width: 980px){
      .controls .card.bg,
      .controls .card.main,
      .controls .card.frame{ grid-column: span 12; }
      .controls .card.title,
      .controls .card.subtitle{ grid-column: span 12; }
      label{ min-width: 160px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1 id="toolTitle">AI Image Frame Tool â€” 2025-12-30 20:59:45</h1>
      <p class="sub">Browser-only â€¢ No backend â€¢ Canvas-only rendering â€¢ Layer order locked: Background â†’ Main â†’ Frame â†’ Title â†’ Subtitle</p>
      <div class="controls">

        <section class="card bg">
          <h2>Background Image <span class="badge">Layer 1 (Bottom)</span></h2>
          <div class="row">
            <label>
              Load Background Image
              <input id="bgFile" type="file" accept="image/*" />
            </label>
            <label>
              Fit Mode
              <select id="bgFit">
                <option value="cover">Cover (fill canvas)</option>
                <option value="contain">Contain (fit inside)</option>
              </select>
            </label>
          </div>
          <div class="row">
            <label>
              Background Opacity (20% â†’ 100%)
              <div class="inline">
                <input id="bgOpacity" type="range" min="20" max="100" step="1" value="100" />
                <input id="bgOpacityNum" class="tight" type="number" min="20" max="100" step="1" value="100" />
              </div>
            </label>
          </div>
          <div class="tiny">Background is not draggable (by design). It always fills the full canvas.</div>
        </section>

        <section class="card main">
          <h2>Main Image <span class="badge">Layer 2</span></h2>
          <div class="row">
            <label>
              Load Main Image
              <input id="mainFile" type="file" accept="image/*" />
            </label>
            <label>
              Main Opacity (20% â†’ 100%)
              <div class="inline">
                <input id="mainOpacity" type="range" min="20" max="100" step="1" value="100" />
                <input id="mainOpacityNum" class="tight" type="number" min="20" max="100" step="1" value="100" />
              </div>
            </label>
          </div>
          <div class="row">
            <label>
              Main Scale (%)
              <div class="inline">
                <input id="mainScale" type="range" min="10" max="300" step="1" value="100" />
                <input id="mainScaleNum" class="tight" type="number" min="10" max="300" step="1" value="100" />
              </div>
            </label>
          </div>
          <div class="btnbar">
            <button id="centerAll" class="secondary" type="button">Auto-center Content</button>
            <button id="fitCanvasToMain" class="secondary" type="button">Canvas = Main Size</button>
            <button id="fitCanvasToBg" class="secondary" type="button">Canvas = Background Size</button>
          </div>
          <div class="tiny"><b>Drag main image on canvas</b> (mouse or touch). The frame moves together with main image.</div>
        </section>

        <section class="card frame">
          <h2>Frame / Border <span class="badge">Layer 3</span></h2>
          <div class="row">
            <label>
              Frame Color
              <input id="frameColor" type="color" value="#ffffff" />
            </label>
            <label>
              Frame Thickness
              <div class="inline">
                <input id="frameThickness" type="range" min="0" max="80" step="1" value="16" />
                <input id="frameThicknessNum" class="tight" type="number" min="0" max="80" step="1" value="16" />
              </div>
            </label>
          </div>
          <div class="row">
            <label>
              Frame Enabled
              <select id="frameEnabled">
                <option value="on">On</option>
                <option value="off">Off</option>
              </select>
            </label>
            <label>
              Frame Padding (around main)
              <div class="inline">
                <input id="framePad" type="range" min="0" max="80" step="1" value="10" />
                <input id="framePadNum" class="tight" type="number" min="0" max="80" step="1" value="10" />
              </div>
            </label>
          </div>
          <div class="tiny">Frame always wraps the main image only (uniform thickness on all sides).</div>
        </section>

        <section class="card title">
          <h2>Title Text <span class="badge">Layer 4</span></h2>
          <div class="row">
            <label>
              Title Text (real-time)
              <input id="titleText" type="text" value="ä¸€èµ·åŠ æ²¹åŠ æ²¹!!!" />
            </label>
          </div>
          <div class="row">
            <label>
              Font Family (macOS Safari Safe)
              <select id="titleFont"></select>
            </label>
            <label>
              Title Color
              <input id="titleColor" type="color" value="#ffffff" />
            </label>
          </div>
          <div class="row">
            <label>
              Font Size (14pt â†’ 800pt)
              <div class="inline">
                <input id="titleSize" type="range" min="14" max="800" step="1" value="72" />
                <input id="titleSizeNum" class="tight" type="number" min="14" max="800" step="1" value="72" />
              </div>
            </label>
          </div>
          <div class="row">
            <label>
              Preset Captions
              <select id="titlePreset">
                <option value="">(Choose a presetâ€¦)</option>
                <option>Thanks for everything</option>
                <option>Pray for everything</option>
                <option>Donâ€™t worry for anything</option>
                <option>Yes, Virginia, there is a Santa Claus</option>
                <option>Be strong and courageous</option>
              </select>
            </label>
            <label>
              Shadow
              <select id="titleShadow">
                <option value="soft" selected>Soft</option>
                <option value="none">None</option>
              </select>
            </label>
          </div>
          <div class="btnbar">
            <button id="titleResetPos" class="secondary" type="button">Reset Title Position</button>
            <button id="randomStyle" type="button">Random Style</button>
          </div>
          <div class="tiny">Drag the title directly on the canvas (mouse or touch). Alignment is center by default.</div>
        </section>

        <section class="card subtitle">
          <h2>Subtitle Text <span class="badge">Layer 5 (Top)</span></h2>
          <div class="row">
            <label>
              Subtitle Text (real-time)
              <input id="subtitleText" type="text" value="Worship is opening ourselves to experience God." />
            </label>
          </div>
          <div class="row">
            <label>
              Font Family (macOS Safari Safe)
              <select id="subtitleFont"></select>
            </label>
            <label>
              Subtitle Color
              <input id="subtitleColor" type="color" value="#d9e6ff" />
            </label>
          </div>
          <div class="row">
            <label>
              Font Size (14pt â†’ 800pt)
              <div class="inline">
                <input id="subtitleSize" type="range" min="14" max="800" step="1" value="36" />
                <input id="subtitleSizeNum" class="tight" type="number" min="14" max="800" step="1" value="36" />
              </div>
            </label>
          </div>
          <div class="row">
            <label>
              Preset Captions
              <select id="subtitlePreset">
                <option value="">(Choose a presetâ€¦)</option>
                <option>åŸŽå¸‚ä¹‹å…‰</option>
                <option>Breaking Free from the Rat Race</option>
                <option>God is the one sitting on the throne.</option>
                <option>Hope â€¢ Peace â€¢ Joy</option>
                <option>Season of Gratitude</option>
              </select>
            </label>
            <label>
              Shadow
              <select id="subtitleShadow">
                <option value="soft" selected>Soft</option>
                <option value="none">None</option>
              </select>
            </label>
          </div>
          <div class="btnbar">
            <button id="subtitleResetPos" class="secondary" type="button">Reset Subtitle Position</button>
            <button id="clearAll" class="danger" type="button">Clear Images</button>
          </div>
          <div class="tiny">Drag the subtitle directly on the canvas (mouse or touch). Layer order is always preserved.</div>
        </section>

        <section class="card canvas">
          <h2>Canvas Preview & Export <span class="badge">Canvas-only</span></h2>
          <div class="canvasWrap">
            <div class="canvasTopRow">
              <div class="hintPills">
                <span class="pill">Drag: Main / Title / Subtitle</span>
                <span class="pill">Mouse + Touch</span>
                <span class="pill">Export: Pixel-perfect PNG</span>
              </div>
              <div class="btnbar" style="margin:0">
                <button id="downloadPng" type="button">Download PNG</button>
              </div>
            </div>

            <div class="row" style="width:100%">
              <label style="flex:1 1 220px; min-width:220px;">
                Canvas Width (px)
                <input id="canvasW" type="number" min="64" max="10000" step="1" value="1200" />
              </label>
              <label style="flex:1 1 220px; min-width:220px;">
                Canvas Height (px)
                <input id="canvasH" type="number" min="64" max="10000" step="1" value="800" />
              </label>
              <div style="flex:0 0 auto; align-self:flex-end; display:flex; gap:10px; flex-wrap:wrap;">
                <button id="applyCanvasSize" class="secondary" type="button">Apply Canvas Size</button>
                <button id="resetDefaults" class="secondary" type="button">Smart Defaults</button>
              </div>
            </div>

            <div class="canvasShell">
              <canvas id="c"></canvas>
            </div>

            <div class="footer">
              <div>Tip: On iPhone/iPad, drag with one finger. Canvas uses <span class="kbd">touch-action: none</span> for smooth dragging.</div>
              <div>Selected layer: <span class="kbd" id="selectedLayer">None</span></div>
            </div>
          </div>
        </section>

      </div>
    </div>
  </header>

  <main class="wrap" style="padding-top:14px">
    <div class="tiny">
      <b>Strict Layer Order (always):</b> Background Image â†’ Main Image â†’ Frame â†’ Title â†’ Subtitle. Exported PNG matches exactly.
    </div>
  </main>

  <script>
    // =========================
    // Version stamp (MANDATORY)
    // =========================
    const VERSION_STAMP = "AI Image Frame Tool â€” 2025-12-30 20:59:45";
    document.title = VERSION_STAMP;
    document.getElementById("toolTitle").textContent = VERSION_STAMP;

    // =========================
    // Canvas + HiDPI
    // =========================
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: true });

    let cssW = 1200, cssH = 800;
    let dpr = 1;

    function setCanvasSize(w, h){
      cssW = clampInt(w, 64, 10000);
      cssH = clampInt(h, 64, 10000);
      dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1)); // Safari-safe clamp
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      canvas.style.width = cssW + "px";
      canvas.style.height = "auto";
      // Keep canvas responsive: width 100% via CSS; so set a max-width to cssW
      canvas.style.maxWidth = cssW + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixel coords
      requestRender();
    }

    // =========================
    // State (Layers)
    // =========================
    const state = {
      background: {
        img: null,
        opacity: 1.0,       // 0.2..1
        fit: "cover"        // cover|contain
      },
      main: {
        img: null,
        opacity: 1.0,       // 0.2..1
        scale: 1.0,         // 0.10..3.00
        x: cssW/2,
        y: cssH/2
      },
      frame: {
        enabled: true,
        color: "#ffffff",
        thickness: 16,
        pad: 10
      },
      title: {
        text: "ä¸€èµ·åŠ æ²¹åŠ æ²¹!!!",
        fontFamily: `"PingFang TC","PingFangTC-Regular","Heiti TC",system-ui,sans-serif`,
        size: 72,
        color: "#ffffff",
        x: cssW/2,
        y: Math.round(cssH * 0.12),
        shadow: "soft"
      },
      subtitle: {
        text: "Worship is opening ourselves to experience God.",
        fontFamily: `"Heiti TC","PingFang TC",system-ui,sans-serif`,
        size: 36,
        color: "#d9e6ff",
        x: cssW/2,
        y: Math.round(cssH * 0.88),
        shadow: "soft"
      }
    };

    // =========================
    // Fonts (MANDATORY ORDER)
    // =========================
    const FONT_OPTIONS = [
      // ðŸ”¹ Traditional Chinese Fonts (ç¹é«”ä¸­æ–‡) â€” MUST remain available for BOTH Title & Subtitle.
      { label: "PingFang TCï¼ˆè˜‹æ–¹-ç¹ï¼‰â€” â­ Primary", value: `"PingFang TC","PingFangTC-Regular","PingFangTC-Medium","PingFangTC-Semibold","Heiti TC",system-ui,sans-serif` },
      { label: "PingFang TC", value: `"PingFang TC","PingFangTC-Regular","Heiti TC",system-ui,sans-serif` },
      { label: "PingFangTC-Regular", value: `"PingFangTC-Regular","PingFang TC","Heiti TC",system-ui,sans-serif` },
      { label: "PingFangTC-Medium", value: `"PingFangTC-Medium","PingFang TC","Heiti TC",system-ui,sans-serif` },
      { label: "PingFangTC-Semibold", value: `"PingFangTC-Semibold","PingFang TC","Heiti TC",system-ui,sans-serif` },
      { label: "Heiti TCï¼ˆé»‘é«”-ç¹ï¼‰", value: `"Heiti TC","PingFang TC",system-ui,sans-serif` },
      { label: "Heiti TC", value: `"Heiti TC","PingFang TC",system-ui,sans-serif` },
      { label: "Heiti TC Light", value: `"Heiti TC Light","Heiti TC","PingFang TC",system-ui,sans-serif` },
      { label: "Heiti TC Medium", value: `"Heiti TC Medium","Heiti TC","PingFang TC",system-ui,sans-serif` },
      { label: "Songti TCï¼ˆå®‹é«”-ç¹ï¼‰", value: `"Songti TC","Songti TC Regular","Songti TC Bold","PingFang TC",system-ui,serif` },
      { label: "Songti TC", value: `"Songti TC","PingFang TC",system-ui,serif` },
      { label: "Songti TC Regular", value: `"Songti TC Regular","Songti TC","PingFang TC",system-ui,serif` },
      { label: "Songti TC Bold", value: `"Songti TC Bold","Songti TC","PingFang TC",system-ui,serif` },
      { label: "Kaiti TCï¼ˆæ¥·é«”-ç¹ï¼‰", value: `"Kaiti TC","Songti TC","PingFang TC",system-ui,serif` },
      { label: "Kaiti TC", value: `"Kaiti TC","Songti TC","PingFang TC",system-ui,serif` },
      // ðŸ”¹ Latin / System Fonts
      { label: "system-ui", value: `system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif` },
      { label: "Arial", value: `Arial,system-ui,sans-serif` },
      { label: "Helvetica", value: `Helvetica,Arial,system-ui,sans-serif` }
    ];

    function populateFontSelect(sel){
      sel.innerHTML = "";
      for (const opt of FONT_OPTIONS){
        const o = document.createElement("option");
        o.textContent = opt.label;
        o.value = opt.value;
        sel.appendChild(o);
      }
    }

    const titleFontSel = document.getElementById("titleFont");
    const subtitleFontSel = document.getElementById("subtitleFont");
    populateFontSelect(titleFontSel);
    populateFontSelect(subtitleFontSel);

    // Default selections
    titleFontSel.value = state.title.fontFamily;
    subtitleFontSel.value = state.subtitle.fontFamily;

    // =========================
    // Helpers
    // =========================
    function clampInt(v, min, max){
      v = Number.isFinite(+v) ? Math.round(+v) : min;
      return Math.max(min, Math.min(max, v));
    }
    function clampFloat(v, min, max){
      v = Number.isFinite(+v) ? +v : min;
      return Math.max(min, Math.min(max, v));
    }
    function randBetween(min, max){ return min + Math.random()*(max-min); }
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function hexColorFromHSL(h, s, l){
      // Simple HSL->RGB
      h = (h%360+360)%360; s = clampFloat(s,0,1); l = clampFloat(l,0,1);
      const c = (1 - Math.abs(2*l - 1)) * s;
      const x = c * (1 - Math.abs((h/60)%2 - 1));
      const m = l - c/2;
      let r=0,g=0,b=0;
      if (h<60){ r=c; g=x; b=0; }
      else if (h<120){ r=x; g=c; b=0; }
      else if (h<180){ r=0; g=c; b=x; }
      else if (h<240){ r=0; g=x; b=c; }
      else if (h<300){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      r = Math.round((r+m)*255);
      g = Math.round((g+m)*255);
      b = Math.round((b+m)*255);
      return "#" + [r,g,b].map(n=>n.toString(16).padStart(2,"0")).join("");
    }

    function setSyncedRangeNumber(rangeEl, numEl, onChange){
      const syncFromRange = () => { numEl.value = rangeEl.value; onChange(rangeEl.value); };
      const syncFromNum   = () => { rangeEl.value = numEl.value; onChange(numEl.value); };
      rangeEl.addEventListener("input", syncFromRange);
      numEl.addEventListener("input", syncFromNum);
    }

    // =========================
    // Image Loading (Safari-safe)
    // =========================
    function loadImageFromFile(file){
      return new Promise((resolve, reject) => {
        if (!file){ reject(new Error("No file")); return; }
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error("Failed to load image")); };
        img.src = url;
        // No crossOrigin needed for local files; keeps canvas export safe.
      });
    }

    // =========================
    // Rendering
    // =========================
    let needsRender = true;
    function requestRender(){ needsRender = true; }

    function clear(){
      ctx.clearRect(0,0,cssW,cssH);
    }

    function drawBackground(){
      const bg = state.background;
      if (!bg.img) return;

      ctx.save();
      ctx.globalAlpha = bg.opacity;

      const iw = bg.img.naturalWidth || bg.img.width;
      const ih = bg.img.naturalHeight || bg.img.height;

      const sx = cssW / iw;
      const sy = cssH / ih;
      const scale = (bg.fit === "contain") ? Math.min(sx, sy) : Math.max(sx, sy);

      const dw = iw * scale;
      const dh = ih * scale;
      const dx = (cssW - dw) / 2;
      const dy = (cssH - dh) / 2;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(bg.img, dx, dy, dw, dh);

      ctx.restore();
    }

    function getMainRect(){
      const m = state.main;
      if (!m.img) return null;

      const iw = m.img.naturalWidth || m.img.width;
      const ih = m.img.naturalHeight || m.img.height;

      // Main is drawn with uniform scale based on its intrinsic size and user scale.
      const scale = m.scale;
      const dw = iw * scale;
      const dh = ih * scale;

      return {
        x: m.x - dw/2,
        y: m.y - dh/2,
        w: dw,
        h: dh,
        cx: m.x,
        cy: m.y
      };
    }

    function drawMain(){
      const m = state.main;
      if (!m.img) return;
      const r = getMainRect();
      if (!r) return;

      ctx.save();
      ctx.globalAlpha = m.opacity;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(m.img, r.x, r.y, r.w, r.h);
      ctx.restore();
    }

    function drawFrame(){
      const f = state.frame;
      const r = getMainRect();
      if (!f.enabled || !r) return;

      const pad = f.pad;
      const t = f.thickness;

      ctx.save();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = f.color;
      ctx.lineWidth = t;
      ctx.lineJoin = "miter";

      // Stroke centered on path; so expand by pad + t/2 to keep uniform "wrap".
      const x = r.x - pad - t/2;
      const y = r.y - pad - t/2;
      const w = r.w + pad*2 + t;
      const h = r.h + pad*2 + t;

      ctx.strokeRect(x, y, w, h);
      ctx.restore();
    }

    function applyTextShadow(which){
      if (which === "none"){
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      } else {
        ctx.shadowColor = "rgba(0,0,0,.55)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
      }
    }

    function drawTextLayer(layer){
      const t = state[layer];
      if (!t.text) return;

      ctx.save();
      ctx.globalAlpha = 1;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // Canvas uses px; we treat "pt" as px for simplicity & consistency in browser.
      // (This keeps UI intuitive. Export matches exactly.)
      ctx.font = `${t.size}px ${t.fontFamily}`;
      ctx.fillStyle = t.color;
      applyTextShadow(t.shadow);

      ctx.fillText(t.text, t.x, t.y);
      ctx.restore();
    }

    function render(){
      if (!needsRender) return;
      needsRender = false;

      clear();

      // STRICT LAYER ORDER (BOTTOM â†’ TOP) â€” must never break:
      drawBackground();         // 1 Background Image Layer
      drawMain();               // 2 Main Image Layer
      drawFrame();              // 3 Frame / Border Layer
      drawTextLayer("title");   // 4 Title Text Layer
      drawTextLayer("subtitle");// 5 Subtitle Text Layer
    }

    function tick(){
      render();
      requestAnimationFrame(tick);
    }

    // =========================
    // Hit Testing (Topmost first)
    // =========================
    function measureTextBox(text, fontSize, fontFamily, x, y){
      ctx.save();
      ctx.font = `${fontSize}px ${fontFamily}`;
      const metrics = ctx.measureText(text || "");
      const w = metrics.width || 0;

      // Safari fallback: approximate height by fontSize if bounding boxes not present.
      const ascent = metrics.actualBoundingBoxAscent || Math.round(fontSize * 0.78);
      const descent = metrics.actualBoundingBoxDescent || Math.round(fontSize * 0.22);
      const h = ascent + descent;

      ctx.restore();

      return {
        x: x - w/2,
        y: y - h/2,
        w,
        h
      };
    }

    function pointInRect(px, py, r){
      return px >= r.x && px <= (r.x + r.w) && py >= r.y && py <= (r.y + r.h);
    }

    function hitTest(px, py){
      // Topmost selectable first: subtitle â†’ title â†’ main
      if (state.subtitle.text){
        const b = measureTextBox(state.subtitle.text, state.subtitle.size, state.subtitle.fontFamily, state.subtitle.x, state.subtitle.y);
        if (pointInRect(px, py, inflateRect(b, 8))) return "subtitle";
      }
      if (state.title.text){
        const b = measureTextBox(state.title.text, state.title.size, state.title.fontFamily, state.title.x, state.title.y);
        if (pointInRect(px, py, inflateRect(b, 8))) return "title";
      }
      const mr = getMainRect();
      if (mr && pointInRect(px, py, mr)) return "main";
      return null;
    }

    function inflateRect(r, pad){
      return { x: r.x - pad, y: r.y - pad, w: r.w + pad*2, h: r.h + pad*2 };
    }

    // =========================
    // Dragging (Mouse + Touch)
    // =========================
    const selectedLayerEl = document.getElementById("selectedLayer");
    let drag = {
      active: false,
      target: null,
      startX: 0,
      startY: 0,
      origX: 0,
      origY: 0,
      pointerId: null
    };

    function setSelected(name){
      selectedLayerEl.textContent = name ? name : "None";
    }

    function getCanvasPointFromClient(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      // We draw in CSS pixels, so use rect (CSS pixels)
      const x = (clientX - rect.left) * (cssW / rect.width);
      const y = (clientY - rect.top) * (cssH / rect.height);
      return { x, y };
    }

    function startDrag(target, pt, pointerId){
      drag.active = true;
      drag.target = target;
      drag.startX = pt.x;
      drag.startY = pt.y;
      drag.pointerId = pointerId;

      if (target === "main"){
        drag.origX = state.main.x;
        drag.origY = state.main.y;
      } else if (target === "title"){
        drag.origX = state.title.x;
        drag.origY = state.title.y;
      } else if (target === "subtitle"){
        drag.origX = state.subtitle.x;
        drag.origY = state.subtitle.y;
      }
      setSelected(target);
    }

    function moveDrag(pt){
      if (!drag.active || !drag.target) return;
      const dx = pt.x - drag.startX;
      const dy = pt.y - drag.startY;

      if (drag.target === "main"){
        state.main.x = drag.origX + dx;
        state.main.y = drag.origY + dy;
      } else if (drag.target === "title"){
        state.title.x = drag.origX + dx;
        state.title.y = drag.origY + dy;
      } else if (drag.target === "subtitle"){
        state.subtitle.x = drag.origX + dx;
        state.subtitle.y = drag.origY + dy;
      }
      requestRender();
    }

    function endDrag(){
      drag.active = false;
      drag.target = null;
      drag.pointerId = null;
    }

    // Pointer Events (preferred)
    canvas.addEventListener("pointerdown", (e) => {
      // prevent scroll/zoom gestures while interacting
      e.preventDefault();
      const pt = getCanvasPointFromClient(e.clientX, e.clientY);
      const target = hitTest(pt.x, pt.y);

      if (!target) { setSelected(null); return; }

      try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
      startDrag(target, pt, e.pointerId);
    }, { passive: false });

    canvas.addEventListener("pointermove", (e) => {
      if (!drag.active) return;
      if (drag.pointerId != null && e.pointerId !== drag.pointerId) return;
      e.preventDefault();
      const pt = getCanvasPointFromClient(e.clientX, e.clientY);
      moveDrag(pt);
    }, { passive: false });

    canvas.addEventListener("pointerup", (e) => {
      if (drag.pointerId != null && e.pointerId !== drag.pointerId) return;
      e.preventDefault();
      endDrag();
    }, { passive: false });

    canvas.addEventListener("pointercancel", (e) => {
      if (drag.pointerId != null && e.pointerId !== drag.pointerId) return;
      e.preventDefault();
      endDrag();
    }, { passive: false });

    // Fallback: mouse (older Safari edge cases)
    canvas.addEventListener("mousedown", (e) => {
      if (window.PointerEvent) return;
      e.preventDefault();
      const pt = getCanvasPointFromClient(e.clientX, e.clientY);
      const target = hitTest(pt.x, pt.y);
      if (!target) { setSelected(null); return; }
      startDrag(target, pt, "mouse");
      const onMove = (ev) => {
        ev.preventDefault();
        moveDrag(getCanvasPointFromClient(ev.clientX, ev.clientY));
      };
      const onUp = (ev) => {
        ev.preventDefault();
        endDrag();
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove, { passive: false });
      window.addEventListener("mouseup", onUp, { passive: false });
    }, { passive: false });

    // Fallback: touch (very old iOS)
    canvas.addEventListener("touchstart", (e) => {
      if (window.PointerEvent) return;
      e.preventDefault();
      const t = e.changedTouches[0];
      const pt = getCanvasPointFromClient(t.clientX, t.clientY);
      const target = hitTest(pt.x, pt.y);
      if (!target) { setSelected(null); return; }
      startDrag(target, pt, "touch");
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      if (window.PointerEvent) return;
      if (!drag.active) return;
      e.preventDefault();
      const t = e.changedTouches[0];
      moveDrag(getCanvasPointFromClient(t.clientX, t.clientY));
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      if (window.PointerEvent) return;
      e.preventDefault();
      endDrag();
    }, { passive: false });

    canvas.addEventListener("touchcancel", (e) => {
      if (window.PointerEvent) return;
      e.preventDefault();
      endDrag();
    }, { passive: false });

    // =========================
    // Controls Wiring
    // =========================
    // Background
    document.getElementById("bgFit").addEventListener("change", (e) => {
      state.background.fit = e.target.value;
      requestRender();
    });

    setSyncedRangeNumber(
      document.getElementById("bgOpacity"),
      document.getElementById("bgOpacityNum"),
      (v) => { state.background.opacity = clampFloat(+v/100, 0.2, 1.0); requestRender(); }
    );

    document.getElementById("bgFile").addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        state.background.img = await loadImageFromFile(file);
        // AI-like enhancement: if no main image yet, fit canvas to background
        if (!state.main.img){
          smartFitCanvasToImage(state.background.img);
        }
        requestRender();
      } catch (err){
        alert("Failed to load background image.");
      }
    });

    // Main
    setSyncedRangeNumber(
      document.getElementById("mainOpacity"),
      document.getElementById("mainOpacityNum"),
      (v) => { state.main.opacity = clampFloat(+v/100, 0.2, 1.0); requestRender(); }
    );

    setSyncedRangeNumber(
      document.getElementById("mainScale"),
      document.getElementById("mainScaleNum"),
      (v) => { state.main.scale = clampFloat(+v/100, 0.10, 3.00); requestRender(); }
    );

    document.getElementById("mainFile").addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try{
        state.main.img = await loadImageFromFile(file);

        // AI-like enhancement: fit canvas to main image (common use)
        smartFitCanvasToImage(state.main.img);

        // Auto-center main & place text
        autoCenterContent();

        // Smart default font sizing
        smartDefaultsTextSizes();

        requestRender();
      }catch(err){
        alert("Failed to load main image.");
      }
    });

    // Frame
    document.getElementById("frameColor").addEventListener("input", (e) => {
      state.frame.color = e.target.value;
      requestRender();
    });

    setSyncedRangeNumber(
      document.getElementById("frameThickness"),
      document.getElementById("frameThicknessNum"),
      (v) => { state.frame.thickness = clampInt(v, 0, 80); requestRender(); }
    );

    setSyncedRangeNumber(
      document.getElementById("framePad"),
      document.getElementById("framePadNum"),
      (v) => { state.frame.pad = clampInt(v, 0, 80); requestRender(); }
    );

    document.getElementById("frameEnabled").addEventListener("change", (e) => {
      state.frame.enabled = (e.target.value === "on");
      requestRender();
    });

    // Title
    document.getElementById("titleText").addEventListener("input", (e) => {
      state.title.text = e.target.value;
      requestRender();
    });
    document.getElementById("titleColor").addEventListener("input", (e) => {
      state.title.color = e.target.value;
      requestRender();
    });
    titleFontSel.addEventListener("change", (e) => {
      state.title.fontFamily = e.target.value; // fallback chain
      requestRender();
    });
    setSyncedRangeNumber(
      document.getElementById("titleSize"),
      document.getElementById("titleSizeNum"),
      (v) => { state.title.size = clampInt(v, 14, 800); requestRender(); }
    );
    document.getElementById("titlePreset").addEventListener("change", (e) => {
      if (e.target.value){
        state.title.text = e.target.value;
        document.getElementById("titleText").value = e.target.value;
        requestRender();
      }
    });
    document.getElementById("titleShadow").addEventListener("change", (e) => {
      state.title.shadow = e.target.value;
      requestRender();
    });
    document.getElementById("titleResetPos").addEventListener("click", () => {
      state.title.x = cssW/2;
      state.title.y = Math.round(cssH * 0.12);
      requestRender();
    });

    // Subtitle
    document.getElementById("subtitleText").addEventListener("input", (e) => {
      state.subtitle.text = e.target.value;
      requestRender();
    });
    document.getElementById("subtitleColor").addEventListener("input", (e) => {
      state.subtitle.color = e.target.value;
      requestRender();
    });
    subtitleFontSel.addEventListener("change", (e) => {
      state.subtitle.fontFamily = e.target.value; // fallback chain
      requestRender();
    });
    setSyncedRangeNumber(
      document.getElementById("subtitleSize"),
      document.getElementById("subtitleSizeNum"),
      (v) => { state.subtitle.size = clampInt(v, 14, 800); requestRender(); }
    );
    document.getElementById("subtitlePreset").addEventListener("change", (e) => {
      if (e.target.value){
        state.subtitle.text = e.target.value;
        document.getElementById("subtitleText").value = e.target.value;
        requestRender();
      }
    });
    document.getElementById("subtitleShadow").addEventListener("change", (e) => {
      state.subtitle.shadow = e.target.value;
      requestRender();
    });
    document.getElementById("subtitleResetPos").addEventListener("click", () => {
      state.subtitle.x = cssW/2;
      state.subtitle.y = Math.round(cssH * 0.88);
      requestRender();
    });

    // Canvas size
    document.getElementById("applyCanvasSize").addEventListener("click", () => {
      const w = clampInt(document.getElementById("canvasW").value, 64, 10000);
      const h = clampInt(document.getElementById("canvasH").value, 64, 10000);
      setCanvasSize(w, h);
      // keep existing positions proportional? We keep absolute (predictable).
      requestRender();
    });

    document.getElementById("canvasW").addEventListener("input", (e) => {
      // no auto-apply; user clicks Apply
    });
    document.getElementById("canvasH").addEventListener("input", (e) => {
      // no auto-apply; user clicks Apply
    });

    // Buttons
    document.getElementById("downloadPng").addEventListener("click", () => {
      // Ensure latest pixels
      requestRender();
      render();

      const url = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = url;
      a.download = "framed.png";
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    document.getElementById("centerAll").addEventListener("click", () => {
      autoCenterContent();
      requestRender();
    });

    document.getElementById("fitCanvasToMain").addEventListener("click", () => {
      if (!state.main.img) return;
      smartFitCanvasToImage(state.main.img);
      autoCenterContent();
      requestRender();
    });

    document.getElementById("fitCanvasToBg").addEventListener("click", () => {
      if (!state.background.img) return;
      smartFitCanvasToImage(state.background.img);
      autoCenterContent();
      requestRender();
    });

    document.getElementById("resetDefaults").addEventListener("click", () => {
      smartDefaultsTextSizes();
      requestRender();
    });

    document.getElementById("randomStyle").addEventListener("click", () => {
      randomizeStyle();
      requestRender();
    });

    document.getElementById("clearAll").addEventListener("click", () => {
      state.background.img = null;
      state.main.img = null;
      document.getElementById("bgFile").value = "";
      document.getElementById("mainFile").value = "";
      requestRender();
    });

    // =========================
    // AI-like enhancements
    // =========================
    function autoCenterContent(){
      // Center main image + frame as a unit
      state.main.x = cssW / 2;
      state.main.y = cssH / 2;

      // Center text, with gentle default offsets
      state.title.x = cssW / 2;
      state.subtitle.x = cssW / 2;

      // If main exists, place title above it and subtitle below it.
      const mr = getMainRect();
      if (mr){
        const topY = Math.max(30, mr.y - 18 - state.frame.pad - state.frame.thickness);
        const bottomY = Math.min(cssH - 30, mr.y + mr.h + 18 + state.frame.pad + state.frame.thickness);
        state.title.y = clampFloat(topY, 20, cssH-20);
        state.subtitle.y = clampFloat(bottomY, 20, cssH-20);
      } else {
        state.title.y = Math.round(cssH * 0.12);
        state.subtitle.y = Math.round(cssH * 0.88);
      }
      setSelected(null);
    }

    function smartDefaultsTextSizes(){
      // Smart font sizing based on canvas width and content length
      const base = Math.max(14, Math.min(800, Math.round(cssW * 0.07)));
      const subBase = Math.max(14, Math.min(800, Math.round(cssW * 0.035)));

      state.title.size = clampInt(base, 14, 800);
      state.subtitle.size = clampInt(subBase, 14, 800);

      // If text is long, reduce size a bit
      const tLen = (state.title.text || "").length;
      const sLen = (state.subtitle.text || "").length;
      if (tLen > 18) state.title.size = clampInt(Math.round(state.title.size * 0.82), 14, 800);
      if (tLen > 30) state.title.size = clampInt(Math.round(state.title.size * 0.72), 14, 800);
      if (sLen > 28) state.subtitle.size = clampInt(Math.round(state.subtitle.size * 0.85), 14, 800);
      if (sLen > 50) state.subtitle.size = clampInt(Math.round(state.subtitle.size * 0.75), 14, 800);

      // Sync UI
      document.getElementById("titleSize").value = state.title.size;
      document.getElementById("titleSizeNum").value = state.title.size;
      document.getElementById("subtitleSize").value = state.subtitle.size;
      document.getElementById("subtitleSizeNum").value = state.subtitle.size;
    }

    function randomizeStyle(){
      // Random style (browser-only): font / size / color (title + subtitle)
      const fonts = FONT_OPTIONS.map(o => o.value);
      state.title.fontFamily = pick(fonts);
      state.subtitle.fontFamily = pick(fonts);

      // Random but readable sizes
      const t = clampInt(Math.round(randBetween(28, Math.min(220, cssW*0.12))), 14, 800);
      const s = clampInt(Math.round(randBetween(18, Math.min(140, cssW*0.07))), 14, 800);
      state.title.size = t;
      state.subtitle.size = s;

      // Random pleasing colors (avoid too dark)
      const h1 = randBetween(0, 360);
      const h2 = (h1 + randBetween(40, 180)) % 360;
      state.title.color = hexColorFromHSL(h1, 0.85, 0.70);
      state.subtitle.color = hexColorFromHSL(h2, 0.75, 0.72);

      // Optionally randomize frame color a bit (keeps tool fun)
      state.frame.color = hexColorFromHSL((h1+20)%360, 0.65, 0.78);

      // Sync UI
      titleFontSel.value = state.title.fontFamily;
      subtitleFontSel.value = state.subtitle.fontFamily;

      document.getElementById("titleSize").value = state.title.size;
      document.getElementById("titleSizeNum").value = state.title.size;
      document.getElementById("subtitleSize").value = state.subtitle.size;
      document.getElementById("subtitleSizeNum").value = state.subtitle.size;

      document.getElementById("titleColor").value = state.title.color;
      document.getElementById("subtitleColor").value = state.subtitle.color;
      document.getElementById("frameColor").value = state.frame.color;
    }

    function smartFitCanvasToImage(img){
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;

      // Keep very large images manageable in UI, but export stays at canvas size.
      // Choose a "nice" max dimension for preview canvas.
      const maxDim = 1800;
      let w = iw, h = ih;
      if (Math.max(iw, ih) > maxDim){
        const s = maxDim / Math.max(iw, ih);
        w = Math.round(iw * s);
        h = Math.round(ih * s);
      }

      document.getElementById("canvasW").value = w;
      document.getElementById("canvasH").value = h;
      setCanvasSize(w, h);

      // Keep main centered after resize
      state.main.x = cssW/2;
      state.main.y = cssH/2;
      state.title.x = cssW/2;
      state.subtitle.x = cssW/2;
      state.title.y = Math.round(cssH * 0.12);
      state.subtitle.y = Math.round(cssH * 0.88);
    }

    // =========================
    // Init
    // =========================
    // Initialize canvas to default inputs
    setCanvasSize(
      clampInt(document.getElementById("canvasW").value, 64, 10000),
      clampInt(document.getElementById("canvasH").value, 64, 10000)
    );

    // Apply initial synced control bindings values
    state.background.opacity = clampFloat(+document.getElementById("bgOpacity").value/100, 0.2, 1.0);
    state.main.opacity = clampFloat(+document.getElementById("mainOpacity").value/100, 0.2, 1.0);
    state.main.scale = clampFloat(+document.getElementById("mainScale").value/100, 0.10, 3.00);
    state.frame.color = document.getElementById("frameColor").value;
    state.frame.thickness = clampInt(document.getElementById("frameThickness").value, 0, 80);
    state.frame.pad = clampInt(document.getElementById("framePad").value, 0, 80);

    // Sync initial text UI -> state already set, but ensure UI reflects state
    document.getElementById("titleText").value = state.title.text;
    document.getElementById("subtitleText").value = state.subtitle.text;

    autoCenterContent();
    smartDefaultsTextSizes();

    requestRender();
    tick();

    // Recompute dpr on resize (Safari iOS rotation)
    window.addEventListener("resize", () => {
      // preserve cssW/cssH; only update internal DPR scaling
      setCanvasSize(cssW, cssH);
      requestRender();
    });
  </script>
</body>
</html>
