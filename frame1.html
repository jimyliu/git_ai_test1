<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>AI Image Frame Tool â€” 2025-12-30 15:00:12</title>
<style>
:root {
--primary: #007AFF;
--bg: #F5F5F7;
--panel: #FFFFFF;
--text: #1D1D1F;
--border: #D2D2D7;
--radius: 12px;
--shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

```
    * { box-sizing: border-box; -webkit-font-smoothing: antialiased; }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
    }

    h1 {
        font-size: 1.2rem;
        font-weight: 600;
        margin-bottom: 20px;
        color: #86868b;
    }

    .app-container {
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 24px;
        width: 100%;
        max-width: 1200px;
        align-items: start;
    }

    @media (max-width: 900px) {
        .app-container { grid-template-columns: 1fr; }
        .canvas-wrapper { order: -1; }
    }

    /* Controls Panel */
    .controls {
        background: var(--panel);
        padding: 24px;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 20px;
        max-height: 90vh;
        overflow-y: auto;
    }

    .control-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
        border-bottom: 1px solid #eee;
        padding-bottom: 16px;
    }
    
    .control-group:last-child { border-bottom: none; }

    label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #666;
        display: flex;
        justify-content: space-between;
    }

    input[type="text"], select {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 1rem;
        outline: none;
        transition: border-color 0.2s;
    }

    input[type="text"]:focus, select:focus {
        border-color: var(--primary);
    }

    input[type="color"] {
        -webkit-appearance: none;
        width: 100%;
        height: 40px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        padding: 0;
        overflow: hidden;
    }
    
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: none; }

    input[type="range"] {
        width: 100%;
        accent-color: var(--primary);
    }

    input[type="file"] {
        font-size: 0.9rem;
    }

    /* Buttons */
    .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    
    button {
        padding: 12px;
        border-radius: 8px;
        border: none;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.1s, opacity 0.2s;
        font-size: 0.9rem;
    }
    
    button:active { transform: scale(0.98); }

    .btn-primary { background: var(--primary); color: white; }
    .btn-secondary { background: #e5e5ea; color: var(--text); }
    .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text); }

    /* Canvas Area */
    .canvas-wrapper {
        background: #e5e5ea; /* Contrast bg */
        border-radius: var(--radius);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 400px;
        padding: 20px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
    }

    canvas {
        max-width: 100%;
        height: auto;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        background: white;
        cursor: grab;
        touch-action: none; /* Critical for iOS drag */
    }
    
    canvas:active { cursor: grabbing; }

    .empty-state {
        color: #888;
        text-align: center;
    }
</style>

```

</head>
<body>

```
<h1>AI Image Frame Tool â€” 2025-12-30 15:00:12</h1>

<div class="app-container">
    <aside class="controls">
        
        <div class="control-group">
            <label>Input Image</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="control-group">
            <label>Frame Settings</label>
            <div style="display:flex; gap:10px; margin-bottom:5px;">
                <input type="color" id="frameColor" value="#ffffff" title="Frame Color">
                <input type="number" id="frameWidthVal" value="20" min="0" max="200" style="width: 60px; padding: 5px; border-radius: 6px; border:1px solid #ccc;">
            </div>
            <input type="range" id="frameWidth" min="0" max="200" value="20">
        </div>

        <div class="control-group">
            <label>Title Layer</label>
            <input type="text" id="titleText" placeholder="Enter Title...">
            
            <div style="margin-top:10px; display:flex; gap:10px;">
                <input type="color" id="titleColor" value="#000000" style="flex:1">
                <input type="number" id="titleSizeVal" value="60" min="14" max="200" style="width: 60px; padding: 5px; border-radius: 6px; border:1px solid #ccc;">
            </div>
            <input type="range" id="titleSize" min="14" max="200" value="60">

            <label style="margin-top:10px;">Font Family</label>
            <select id="titleFont"></select>
        </div>

        <div class="control-group">
            <label>Subtitle Layer</label>
            <input type="text" id="subText" placeholder="Enter Subtitle...">
            
            <div style="margin-top:10px; display:flex; gap:10px;">
                <input type="color" id="subColor" value="#666666" style="flex:1">
                <input type="number" id="subSizeVal" value="30" min="14" max="200" style="width: 60px; padding: 5px; border-radius: 6px; border:1px solid #ccc;">
            </div>
            <input type="range" id="subSize" min="14" max="200" value="30">
            
            <label style="margin-top:10px;">Font Family</label>
            <select id="subFont"></select>
        </div>

        <div class="control-group">
            <label>AI Tools</label>
            <div class="btn-group">
                <button class="btn-secondary" id="btnInspire">ðŸ’¡ Caption</button>
                <button class="btn-secondary" id="btnRandomStyle">ðŸŽ¨ Style</button>
            </div>
            <button class="btn-outline" id="btnCenter" style="margin-top:10px; width:100%;">Target Center</button>
        </div>

        <button class="btn-primary" id="btnDownload">Download PNG</button>

    </aside>

    <main class="canvas-wrapper">
        <canvas id="canvas"></canvas>
        <div id="emptyState" class="empty-state">
            <h3>No Image Loaded</h3>
            <p>Upload an image to start framing.</p>
        </div>
    </main>
</div>

<script>
    // --- Configuration & State ---
    const FONTS = [
        { name: "PingFang TC (Primary)", val: '"PingFang TC", "PingFangTC-Regular", "Heiti TC", system-ui, sans-serif' },
        { name: "PingFang Medium", val: '"PingFangTC-Medium", "PingFang TC", system-ui, sans-serif' },
        { name: "PingFang Semibold", val: '"PingFangTC-Semibold", "PingFang TC", system-ui, sans-serif' },
        { name: "Heiti TC (Traditional)", val: '"Heiti TC", "Heiti TC Light", "PingFang TC", sans-serif' },
        { name: "Songti TC (Serif)", val: '"Songti TC", "Songti TC Regular", serif' },
        { name: "Songti TC Bold", val: '"Songti TC Bold", "Songti TC", serif' },
        { name: "Kaiti TC (Calligraphy)", val: '"Kaiti TC", "Kaiti SC", serif' },
        { name: "System UI", val: 'system-ui, -apple-system, sans-serif' },
        { name: "Helvetica", val: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: "Arial", val: 'Arial, sans-serif' }
    ];

    const PRESETS = [
        { t: "Morning Light", s: "Capture the moment" },
        { t: "City Vibes", s: "Urban exploration" },
        { t: "Quiet Mind", s: "Focus on the present" },
        { t: "Deep Focus", s: "Work in progress" },
        { t: "Nature's Path", s: "Walk with purpose" }
    ];

    const state = {
        img: null,
        frame: { color: "#ffffff", width: 40 },
        title: { text: "Visual Story", x: 0, y: 0, color: "#000000", size: 80, font: FONTS[0].val },
        sub: { text: "2025 Collection", x: 0, y: 0, color: "#666666", size: 32, font: FONTS[0].val },
        isDragging: null, // 'title' or 'sub' or null
        dragOffsetX: 0,
        dragOffsetY: 0
    };

    // --- DOM Elements ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const emptyState = document.getElementById('emptyState');
    const imgInput = document.getElementById('imageInput');

    // Inputs
    const els = {
        frameColor: document.getElementById('frameColor'),
        frameWidth: document.getElementById('frameWidth'),
        frameWidthVal: document.getElementById('frameWidthVal'),
        
        titleText: document.getElementById('titleText'),
        titleColor: document.getElementById('titleColor'),
        titleSize: document.getElementById('titleSize'),
        titleSizeVal: document.getElementById('titleSizeVal'),
        titleFont: document.getElementById('titleFont'),

        subText: document.getElementById('subText'),
        subColor: document.getElementById('subColor'),
        subSize: document.getElementById('subSize'),
        subSizeVal: document.getElementById('subSizeVal'),
        subFont: document.getElementById('subFont'),
    };

    // --- Initialization ---
    function init() {
        // Populate Font Selectors
        [els.titleFont, els.subFont].forEach(sel => {
            FONTS.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.val;
                opt.textContent = f.name;
                sel.appendChild(opt);
            });
        });

        // Set initial UI values from state
        els.frameWidth.value = state.frame.width;
        els.frameWidthVal.value = state.frame.width;
        
        els.titleText.value = state.title.text;
        els.titleSize.value = state.title.size;
        els.titleSizeVal.value = state.title.size;
        
        els.subText.value = state.sub.text;
        els.subSize.value = state.sub.size;
        els.subSizeVal.value = state.sub.size;
    }

    // --- Core Rendering ---
    function draw() {
        if (!state.img) return;

        // 1. Clear & Setup
        canvas.width = state.img.naturalWidth;
        canvas.height = state.img.naturalHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 2. Draw Image
        ctx.drawImage(state.img, 0, 0);

        // 3. Draw Frame (Uniform Border)
        // We draw "inside" the canvas edges
        if (state.frame.width > 0) {
            const w = state.frame.width;
            ctx.lineWidth = w;
            ctx.strokeStyle = state.frame.color;
            ctx.lineJoin = 'miter'; 
            // Stroke is centered on path. To stay inside:
            // Path rect is width/2 from edge.
            ctx.strokeRect(w/2, w/2, canvas.width - w, canvas.height - w);
        }

        // 4. Draw Text
        drawTextLayer(state.title);
        drawTextLayer(state.sub);
    }

    function drawTextLayer(layer) {
        if (!layer.text) return;
        ctx.font = `${layer.size}px ${layer.font}`;
        ctx.fillStyle = layer.color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // Shadow for readability
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;

        ctx.fillText(layer.text, layer.x, layer.y);
        
        // Reset shadow
        ctx.shadowColor = "transparent";
    }

    // --- Event Handling ---

    // Image Upload
    imgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (evt) => {
            const img = new Image();
            img.onload = () => {
                state.img = img;
                emptyState.style.display = 'none';
                canvas.style.display = 'block';
                
                // Smart Defaults
                resetPositions();
                autoScaleText();
                
                draw();
            };
            img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
    });

    // Frame Controls
    const updateFrame = () => {
        state.frame.color = els.frameColor.value;
        state.frame.width = parseInt(els.frameWidth.value);
        els.frameWidthVal.value = state.frame.width;
        draw();
    };
    els.frameColor.addEventListener('input', updateFrame);
    els.frameWidth.addEventListener('input', updateFrame);
    els.frameWidthVal.addEventListener('input', (e) => {
        els.frameWidth.value = e.target.value;
        updateFrame();
    });

    // Text Controls (Generic Handler)
    const setupTextHandler = (layerName, elPrefix) => {
        const update = () => {
            state[layerName].text = els[elPrefix + 'Text'].value;
            state[layerName].color = els[elPrefix + 'Color'].value;
            state[layerName].size = parseInt(els[elPrefix + 'Size'].value);
            state[layerName].font = els[elPrefix + 'Font'].value;
            
            // Sync numeric inputs
            els[elPrefix + 'SizeVal'].value = state[layerName].size;
            draw();
        };

        ['Text', 'Color', 'Size', 'Font'].forEach(key => {
            els[elPrefix + key].addEventListener('input', update);
        });
        
        // Numeric Input Sync
        els[elPrefix + 'SizeVal'].addEventListener('input', (e) => {
            els[elPrefix + 'Size'].value = e.target.value;
            update();
        });
    };

    setupTextHandler('title', 'title');
    setupTextHandler('sub', 'sub');

    // --- Positioning Logic ---

    function resetPositions() {
        if(!state.img) return;
        state.title.x = canvas.width / 2;
        state.title.y = canvas.height * 0.85;
        state.sub.x = canvas.width / 2;
        state.sub.y = canvas.height * 0.92;
    }

    function autoScaleText() {
        if(!state.img) return;
        // Rough heuristic: Title is 5% of height, Sub is 2.5%
        const h = state.img.naturalHeight;
        const tSize = Math.max(14, Math.round(h * 0.05));
        const sSize = Math.max(14, Math.round(h * 0.025));
        
        state.title.size = tSize;
        state.sub.size = sSize;
        
        els.titleSize.value = tSize;
        els.titleSizeVal.value = tSize;
        els.subSize.value = sSize;
        els.subSizeVal.value = sSize;
    }

    // --- Drag & Drop System (Mouse & Touch) ---

    function getCanvasCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        let clientX, clientY;
        
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function isHit(pos, layer) {
        if (!layer.text) return false;
        ctx.font = `${layer.size}px ${layer.font}`;
        const metrics = ctx.measureText(layer.text);
        const height = layer.size; // approximate
        const width = metrics.width;
        
        // Check bounding box (centered alignment)
        const left = layer.x - (width / 2);
        const right = layer.x + (width / 2);
        const top = layer.y - (height / 2);
        const bottom = layer.y + (height / 2);
        
        return (pos.x >= left && pos.x <= right && pos.y >= top && pos.y <= bottom);
    }

    function handleStart(e) {
        if (!state.img) return;
        const pos = getCanvasCoords(e);
        
        // Check Subtitle first (usually smaller/on top visually)
        if (isHit(pos, state.sub)) {
            state.isDragging = 'sub';
            state.dragOffsetX = pos.x - state.sub.x;
            state.dragOffsetY = pos.y - state.sub.y;
        } else if (isHit(pos, state.title)) {
            state.isDragging = 'title';
            state.dragOffsetX = pos.x - state.title.x;
            state.dragOffsetY = pos.y - state.title.y;
        }
    }

    function handleMove(e) {
        if (!state.isDragging || !state.img) return;
        e.preventDefault(); // Stop scroll on mobile

        const pos = getCanvasCoords(e);
        const layer = state[state.isDragging];
        
        layer.x = pos.x - state.dragOffsetX;
        layer.y = pos.y - state.dragOffsetY;
        
        draw();
    }

    function handleEnd() {
        state.isDragging = null;
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseout', handleEnd);

    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd);

    // --- AI / Helper Functions ---

    document.getElementById('btnCenter').addEventListener('click', () => {
        resetPositions();
        draw();
    });

    document.getElementById('btnInspire').addEventListener('click', () => {
        const random = PRESETS[Math.floor(Math.random() * PRESETS.length)];
        els.titleText.value = random.t;
        els.subText.value = random.s;
        // Update state & UI
        els.titleText.dispatchEvent(new Event('input'));
        els.subText.dispatchEvent(new Event('input'));
    });

    document.getElementById('btnRandomStyle').addEventListener('click', () => {
        // Random Font
        const rFont = FONTS[Math.floor(Math.random() * FONTS.length)].val;
        els.titleFont.value = rFont;
        els.subFont.value = rFont;
        
        // Random Color (Pastels/Muted usually look better)
        const colors = ['#ffffff', '#000000', '#FF3B30', '#FF9500', '#007AFF', '#5856D6'];
        const rCol = colors[Math.floor(Math.random() * colors.length)];
        els.titleColor.value = rCol;
        
        // Trigger updates
        state.title.font = rFont;
        state.sub.font = rFont;
        state.title.color = rCol;
        draw();
    });

    document.getElementById('btnDownload').addEventListener('click', () => {
        if (!state.img) return alert("Please upload an image first.");
        
        const link = document.createElement('a');
        link.download = `framed-image-${Date.now()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    });

    // Initialize
    init();

</script>

```

</body>
</html>
